trigger:
  branches:
    include:
      - master
      - refs/tags/*.*.*
      - refs/tags/*.*.*.*
    exclude:
      - refs/tags/*-ci*

pr:
  branches:
    include:
      - master
  paths:
    exclude:
      - docs/*
      - README.md

resources:
  - repo: self

variables:
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    iscibuild: ${{ true }}
    isreleasebuild: ${{ false }}
    isprbuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)) ]
    version: $[ format('{0}{1:yyyyMMdd}{2}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)) ]
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/tags/') }}:
    isreleasebuild: ${{ true }}
    iscibuild: ${{ false }}
    isprbuild: ${{ false }}
    tag: $[ replace(variables['Build.SourceBranch'], 'refs/tags/', '') ]
    version: $[ replace(variables['Build.SourceBranch'], 'refs/tags/', '') ]
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
    isprbuild: ${{ true }}
    iscibuild: ${{ false }}
    isreleasebuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}_pr{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/pull/', ''), '/merge', '')) ]
    version: $[ format('{0}{1:yyyyMMdd}{2}+pr{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/pull/', ''), '/merge', '')) ]
  ${{ else }}:
    isprbuild: ${{ false }}
    isreleasebuild: ${{ false }}
    iscibuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}_{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/heads/', ''), '/', '-')) ] 
    version: $[ format('{0}{1:yyyyMMdd}{2}+{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/heads/', ''), '/', '-')) ] 

    
  docker_repo: "rnwood/smtp4dev"
  docker_registry: "dockerhub-rnwood"
  netcoresdk_version: "8.0.201"
  
  # GitHub API token for PR notifications - should be configured as secret variable
  # GITHUB_TOKEN: $(GITHUB_API_TOKEN)
  # Build includes NuGet and npm package caching for improved performance

stages:
  - stage: Init
    displayName: Init
    jobs:
      - job: Init
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - powershell: |
              Write-Host "IsReleaseBuild=$(isreleasebuild) IsCIBuild=$(iscibuild) isprbuild=$(isprbuild)"
              Write-Host "Tag=$(tag)"
              Write-Host "Version=$(version)"
            displayName: Display build details
          - powershell: Write-Host "##vso[build.updatebuildnumber]$(tag) $(Build.BuildNumber)"
            displayName: Update build details
  - stage: Build
    displayName: Build
    condition: succeeded()
    jobs:
      - job: BuildMatrix
        displayName: Build and test - 
        pool:
          vmImage: $(vmImage)
        strategy:
          matrix:
            noruntime:
              platformName: noruntime
              buildArgs: ""
              vmImage: "ubuntu-22.04"
              runTests: ${{ false }}
            win-x64:
              platformName: win-x64
              buildArgs: "-r win-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: "windows-2022"
              runTests: ${{ true }}
            linux-x64:
              platformName: linux-x64
              buildArgs: "-r linux-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: "ubuntu-22.04"
              runTests: ${{ true }}
            # osx-x64:
            #   platformName: osx-x64
            #   buildArgs: "-r osx-x64 --self-contained -p:PublishSingleFile=true"
            #   vmImage: "macOS-11"
            #   runTests: ${{ true }}
            linux-musl-x64:
              platformName: linux-musl-x64
              buildArgs: "-r linux-musl-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: ubuntu-22.04
              runTests: ${{ false }}
            win-arm64:
              platformName: win-arm64
              buildArgs: "-r win-arm64 --self-contained -p:PublishSingleFile=true"
              vmImage: windows-2022
              runTests: ${{ false }}
            linux-arm:
              platformName: linux-arm
              buildArgs: "-r linux-arm --self-contained -p:PublishSingleFile=true"
              vmImage: ubuntu-22.04
              runTests: ${{ false }}
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages based on all project files and solution
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
            condition: ne(variables['Agent.OS'], 'Windows_NT')
          
          # Windows-specific NuGet cache (different default path)
          - task: Cache@2
            displayName: Cache NuGet packages (Windows)
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
            condition: eq(variables['Agent.OS'], 'Windows_NT')
          
          # Cache npm packages based on package-lock.json
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build $(platformName)
            inputs:
              command: build
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              arguments: '-c Release $(buildArgs) -p:version=$(version)'
            env:
              ${{ if ne(variables['Agent.OS'], 'Windows_NT') }}:
                NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          - task: DotNetCoreCLI@2
            displayName: Publish $(platformName)
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              arguments: '-c Release $(buildArgs) -p:version=$(version) -o "$(Build.ArtifactStagingDirectory)/$(platformName)"'
            env:
              ${{ if ne(variables['Agent.OS'], 'Windows_NT') }}:
                NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          - task: ExtractFiles@1
            displayName: Extract files for E2E tests
            condition: and(succeeded(), eq(variables['runTests'], true))
            inputs:
              archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev.zip'
              destinationFolder: $(Agent.TempDirectory)/e2e
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Run SmtpServer Tests
            inputs:
              command: test
              projects: smtpserver/Rnwood.SmtpServer.Tests
              configuration: release
              arguments: '--collect:"XPlat Code Coverage"'
              publishTestResults: true
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Build Test Project for Playwright
            inputs:
              command: build
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '-c Release -o bin/playwright'

          - task: PowerShell@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Install Playwright Browsers
            timeoutInMinutes: 15
            inputs:
              targetType: inline
              script: |
                # Install Playwright browsers using the project's installation method
                Write-Host "Starting Playwright browser installation process..."
                Write-Host "Current working directory: $(Get-Location)"
                
                # Find playwright.ps1 in the forced output directory
                $baseDir = "bin/playwright"
                $playwrightScript = "$baseDir/playwright.ps1"
                
                Write-Host "Searching for playwright.ps1 script..."
                Write-Host "Expected path: $playwrightScript"
                
                if (-not (Test-Path $playwrightScript)) {
                  Write-Error "âœ— Playwright script not found at expected path: $playwrightScript"
                  # Enhanced debugging - list all contents
                  Write-Host "Detailed directory listing for debugging:"
                  if (Test-Path $baseDir) {
                    Write-Host "Contents of $($baseDir):"
                    Get-ChildItem -Path $baseDir -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
                    Write-Host ""
                    Write-Host "Searching for any playwright.ps1 files:"
                    Get-ChildItem -Path $baseDir -Recurse -Name "playwright.ps1" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  Found: $baseDir/$_" }
                  } else {
                    Write-Host "Base directory $baseDir does not exist!"
                  }
                  exit 1
                }
                
                Write-Host "âœ“ Found playwright.ps1 at: $playwrightScript"
                
                # Use the generated playwright.ps1 script (works on both Windows and Linux)
                Write-Host "Installing Playwright browser using script: $playwrightScript"
                Write-Host "File exists check: $(Test-Path $playwrightScript)"
                
                try {
                  if ($IsLinux) {
                    Write-Host "Installing Chromium with system dependencies (this may take several minutes)..."
                    Write-Host "Running command: pwsh $playwrightScript install chromium --with-deps"
                    # Don't capture output - let it stream directly to avoid hanging
                    pwsh $playwrightScript install chromium --with-deps
                    $exitCode = $LASTEXITCODE
                  } else {
                    Write-Host "Installing Chromium..."
                    Write-Host "Running command: pwsh $playwrightScript install chromium"
                    # Don't capture output - let it stream directly to avoid hanging
                    pwsh $playwrightScript install chromium
                    $exitCode = $LASTEXITCODE
                  }
                  
                  if ($exitCode -ne 0) {
                    Write-Error "Playwright installation failed with exit code $exitCode"
                    exit 1
                  }
                } catch {
                  Write-Error "Playwright installation failed with exception: $_"
                  exit 1
                }
                
                Write-Host "âœ“ Playwright browser installation completed successfully"
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Run Tests
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)/e2e
              SMTP4DEV_E2E_BINARY: $(Agent.TempDirectory)/e2e/Rnwood.Smtp4dev
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Tests
              configuration: release
              arguments: '--collect:"XPlat Code Coverage"'
              publishTestResults: true
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Install ReportGenerator Tool
            inputs:
              command: custom
              custom: tool
              arguments: 'install --global dotnet-reportgenerator-globaltool'
          - task: PowerShell@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Generate Coverage Reports
            inputs:
              targetType: inline
              script: |
                Write-Host "Generating coverage reports..."
                $coverageFiles = Get-ChildItem -Path "$(Agent.TempDirectory)" -Recurse -Include "coverage.cobertura.xml" | ForEach-Object { $_.FullName }
                Write-Host "Found coverage files: $($coverageFiles -join ', ')"
                
                if ($coverageFiles.Count -gt 0) {
                  $reportsArg = $coverageFiles -join ";"
                  $targetDir = "$(Agent.TempDirectory)/CoverageReports"
                  
                  reportgenerator -reports:"$reportsArg" -targetdir:"$targetDir" -reporttypes:"Cobertura;HtmlInline_AzurePipelines;JsonSummary;Badges" -verbosity:Info
                  
                  Write-Host "Coverage reports generated in: $targetDir"
                  
                  # Display summary
                  if (Test-Path "$targetDir/Summary.json") {
                    $summary = Get-Content "$targetDir/Summary.json" | ConvertFrom-Json
                    Write-Host "Line Coverage: $($summary.summary.linecoverage)%"
                    Write-Host "Branch Coverage: $($summary.summary.branchcoverage)%"
                    Write-Host "Method Coverage: $($summary.summary.methodcoverage)%"
                  }
                } else {
                  Write-Host "No coverage files found."
                } 
          - task: PublishCodeCoverageResults@1
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Publish Code Coverage Results
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/CoverageReports/Cobertura.xml'
              reportDirectory: '$(Agent.TempDirectory)/CoverageReports'
              failIfCoverageEmpty: false
          - task: PublishPipelineArtifact@1
            condition: and(succeeded(), eq(variables['runTests'], true), eq(variables['platformName'], 'linux-x64'))
            displayName: Publish Coverage Reports as Artifact
            inputs:
              targetPath: '$(Agent.TempDirectory)/CoverageReports'
              artifact: 'CoverageReports'
              publishLocation: 'pipeline'
          - powershell: move-item $(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev.zip $(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev-$(platformName)-$(tag).zip
            displayName: Rename artifact
          - publish: $(Build.ArtifactStagingDirectory)/$(platformName)
            artifact: $(platformName)
          
            
      - job: BuildGlobalTool
        dependsOn:
        displayName: Build - .NET Global Tool
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build .NET Core Global Tool
            inputs:
              command: custom
              custom: pack
              arguments: '-c Release -p:PackAsTool=true -p:version=$(version) -o "$(Build.ArtifactStagingDirectory)/dotnetglobaltool" Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj'
          - publish: $(Build.ArtifactStagingDirectory)/dotnetglobaltool
            artifact: dotnetglobaltool

      - job: BuildDesktop
        dependsOn:
        displayName: Build - Desktop
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build .NET Core - win-x64-desktop
            inputs:
              command: publish
              projects: "Rnwood.Smtp4dev.Desktop/Rnwood.Smtp4dev.Desktop.csproj"
              publishWebProjects: false
              arguments: '-c Release -r win-x64 -p:version=$(version) --self-contained -p:PublishSingleFile=true -o "$(Build.ArtifactStagingDirectory)/win-x64-desktop"'
          - task: ExtractFiles@1
            displayName: Extract files for E2E tests
            inputs:
              archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop.zip'
              destinationFolder: $(Agent.TempDirectory)/e2e
          - task: DotNetCoreCLI@2
            displayName: Run Tests
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)/e2e
              SMTP4DEV_E2E_BINARY: $(Agent.TempDirectory)/e2e/Rnwood.Smtp4dev.Desktop
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Desktop.Tests
              configuration: release
              arguments: '--collect:"XPlat Code Coverage"'
              publishTestResults: true
          - powershell: move-item $(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop.zip $(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip
            displayName: Rename artifact
          - publish: $(Build.ArtifactStagingDirectory)/win-x64-desktop
            artifact: win-x64-desktop

          # - task: DotNetCoreCLI@2run
          #   displayName: Build .NET Core - linux-x64-desktop
          #   inputs:
          #     command: publish
          #     projects: 'Rnwood.Smtp4dev.Desktop/Rnwood.Smtp4dev.Desktop.csproj'
          #     publishWebProjects: false
          #     arguments: '-c Release -r linux-x64 -p:version=$(version) --self-contained -p:PublishSingleFile=true -o "$(Build.ArtifactStagingDirectory)/linux-x64-desktop"'
          # - powershell: move-item $(Build.ArtifactStagingDirectory)/linux-x64-desktop/Rnwood.Smtp4dev.Desktop.zip $(Build.ArtifactStagingDirectory)/linux-x64-desktop/Rnwood.Smtp4dev.Desktop-linux-x64-$(tag).zip
          #   displayName: Rename artifact
          # - publish: $(Build.ArtifactStagingDirectory)/linux-x64-desktop
          #   artifact: linux-x64-desktop
      - job: DockerBuildLinux
        displayName: DockerBuild - Linux
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -o out'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.linux"
              arguments: "--build-arg version=$(version) -t $(docker_repo):linux-amd64-$(tag)"
          # - task: DotNetCoreCLI@2
          #   displayName: Run Tests
          #   env:
          #     SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)
          #     SMTP4DEV_E2E_USEDEFAULTDBPATH: 1
          #     SMTP4DEV_E2E_BINARY: docker
          #     SMTP4DEV_E2E_ARGS: |
          #       run
          #       -i
          #       -p
          #       25:25
          #       -p
          #       80:80
          #       -p
          #       110:110
          #       $(docker_repo):linux-amd64-$(tag)
          #       --urls=http://*:80
          #       --smtpport=25
          #       --imapport=110
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                linux-amd64-$(tag)
      - job: DockerBuildLinuxArm64
        displayName: DockerBuild - Linux - ARM64
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -o out'
          - task: CmdLine@2
            displayName: 'Install emulator'
            inputs:
              script: 'sudo apt-get update && sudo apt-get install -y qemu qemu-user-static'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.linux.arm64"
              arguments: "--platform linux/arm64 --build-arg version=$(version) -t $(docker_repo):linux-arm64-$(tag)"
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                linux-arm64-$(tag)
      - job: DockerBuildWindows
        displayName: DockerBuild - Windows LTSC 2019
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -r win-x64 --self-contained -o out'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.windows.ltsc2019"
              arguments: "--build-arg version=$(version) -t $(docker_repo):windows-ltsc2019-amd64-$(tag)"
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.windows.ltsc2022"
              arguments: "--build-arg version=$(version) -t $(docker_repo):windows-ltsc2022-amd64-$(tag)"
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                windows-ltsc2019-amd64-$(tag)
                windows-ltsc2022-amd64-$(tag)
      - job: DockerManifest
        displayName: Docker Create Manifest
        condition: and(or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true)), succeeded('DockerBuildLinux'), succeeded('DockerBuildLinuxArm64'), succeeded('DockerBuildWindows'))

        dependsOn:
          - DockerBuildLinux
          - DockerBuildLinuxArm64
          - DockerBuildWindows
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "windows-2022"
        steps:
          - task: Docker@2
            displayName: Login.
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Create cross platform manifest
            inputs:
              targetType: inline
              script: |
                docker manifest create $(docker_repo):$(tag) $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-arm64-$(tag)
                docker manifest push $(docker_repo):$(tag)
   
  - stage: ReportCoverage
    displayName: Report Coverage to GitHub
    condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))
    dependsOn: 
      - Build
    jobs:
      - job: ReportToGitHub
        displayName: Report Coverage to GitHub
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: self
            fetchDepth: 1
          - task: DownloadPipelineArtifact@2
            displayName: Download Coverage Reports
            inputs:
              buildType: 'current'
              artifactName: 'CoverageReports'
              targetPath: '$(System.DefaultWorkingDirectory)/CoverageReports'
            continueOnError: true
          - task: PowerShell@2
            displayName: Enhanced Coverage Report to PR
            condition: and(succeeded(), ne(variables['GITHUB_TOKEN'], ''))
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
            inputs:
              targetType: inline
              script: |
                $repoOwner = "rnwood"
                $repoName = "smtp4dev"
                $prNumber = "$(System.PullRequest.PullRequestNumber)"
                $buildUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                
                # Check if coverage reports exist
                $summaryFile = "$(System.DefaultWorkingDirectory)/CoverageReports/Summary.json"
                if (-not (Test-Path $summaryFile)) {
                  Write-Host "No coverage summary found. Skipping GitHub coverage report."
                  exit 0
                }
                
                Write-Host "Enhanced Coverage Reporter"
                Write-Host "========================="
                
                # Read coverage summary
                $summary = Get-Content $summaryFile | ConvertFrom-Json
                $lineCoverage = [math]::Round($summary.summary.linecoverage, 1)
                $branchCoverage = [math]::Round($summary.summary.branchcoverage, 1)
                $methodCoverage = [math]::Round($summary.summary.methodcoverage, 1)
                
                Write-Host "Overall Coverage: Line: $lineCoverage%, Branch: $branchCoverage%, Method: $methodCoverage%"
                
                # For now, we don't have base coverage comparison (can be added later)
                # Future enhancement: Download base branch coverage for comparison
                # To implement PR deltas:
                # 1. Get base branch name: $(System.PullRequest.TargetBranch)
                # 2. Download artifact from latest successful build on base branch
                # 3. Compare current vs base coverage using enhanced script logic
                # 4. Add delta columns to namespace table and overall summary
                $showDeltas = $false
                
                # Group classes by namespace
                $namespaceGroups = @{}
                foreach ($assembly in $summary.coverage.assemblies) {
                    foreach ($class in $assembly.classesinassembly) {
                        $className = $class.name
                        
                        # Extract namespace from class name (handle nested classes)
                        $namespace = ""
                        if ($className -match '^([^<]+?)\.([^\.]+)$') {
                            # Simple case: Namespace.ClassName
                            $namespace = $matches[1]
                        } elseif ($className -match '^([^<]+?)\.([^\.]+?)\/') {
                            # Nested class case: Namespace.ClassName/NestedClass  
                            $namespace = $matches[1]
                        } elseif ($className -match '^([^<]+?)\.([^\.]+?)\.([^\.\/]+)$') {
                            # Two-level namespace: Namespace.SubNamespace.ClassName
                            $namespace = $matches[1] + "." + $matches[2]
                        } else {
                            # Fallback - use the part before the last component
                            $parts = $className -split '\.'
                            if ($parts.Length -gt 1) {
                                $namespace = ($parts[0..($parts.Length-2)] -join ".")
                            } else {
                                $namespace = "Global"
                            }
                        }
                        
                        if (-not $namespaceGroups.ContainsKey($namespace)) {
                            $namespaceGroups[$namespace] = @{
                                Classes = @()
                                TotalCoverableLines = 0
                                TotalCoveredLines = 0
                                TotalBranches = 0
                                TotalCoveredBranches = 0
                                TotalMethods = 0
                                TotalCoveredMethods = 0
                                ClassCount = 0
                            }
                        }
                        
                        $namespaceGroups[$namespace].Classes += $class
                        $namespaceGroups[$namespace].TotalCoverableLines += $class.coverablelines
                        $namespaceGroups[$namespace].TotalCoveredLines += $class.coveredlines
                        $namespaceGroups[$namespace].TotalBranches += $class.totalbranches
                        $namespaceGroups[$namespace].TotalCoveredBranches += $class.coveredbranches
                        $namespaceGroups[$namespace].TotalMethods += $class.totalmethods
                        $namespaceGroups[$namespace].TotalCoveredMethods += $class.coveredmethods
                        $namespaceGroups[$namespace].ClassCount += 1
                    }
                }
                
                # Calculate namespace-level coverage percentages
                $namespaceStats = @()
                foreach ($namespace in $namespaceGroups.Keys | Sort-Object) {
                    $group = $namespaceGroups[$namespace]
                    
                    $lineCov = if ($group.TotalCoverableLines -gt 0) { [math]::Round(($group.TotalCoveredLines / $group.TotalCoverableLines) * 100, 1) } else { 0 }
                    $branchCov = if ($group.TotalBranches -gt 0) { [math]::Round(($group.TotalCoveredBranches / $group.TotalBranches) * 100, 1) } else { 0 }
                    $methodCov = if ($group.TotalMethods -gt 0) { [math]::Round(($group.TotalCoveredMethods / $group.TotalMethods) * 100, 1) } else { 0 }
                    
                    $namespaceStats += [PSCustomObject]@{
                        Namespace = $namespace
                        LinePercent = $lineCov
                        BranchPercent = $branchCov
                        MethodPercent = $methodCov
                        ClassCount = $group.ClassCount
                        CoveredLines = $group.TotalCoveredLines
                        CoverableLines = $group.TotalCoverableLines
                        CoveredBranches = $group.TotalCoveredBranches
                        TotalBranches = $group.TotalBranches
                        CoveredMethods = $group.TotalCoveredMethods
                        TotalMethods = $group.TotalMethods
                    }
                }
                
                Write-Host "`nNamespace Coverage Breakdown:"
                Write-Host "============================="
                foreach ($ns in $namespaceStats) {
                    Write-Host "$($ns.Namespace): Line: $($ns.LinePercent)%, Branch: $($ns.BranchPercent)%, Method: $($ns.MethodPercent)% ($($ns.ClassCount) classes)"
                }
                
                # Generate enhanced GitHub comment
                function Get-CoverageBadge($percentage) {
                    if ($percentage -ge 80) { return "ðŸŸ¢" }
                    elseif ($percentage -ge 60) { return "ðŸŸ¡" }
                    else { return "ðŸ”´" }
                }
                
                $lineBadge = Get-CoverageBadge $lineCoverage
                $branchBadge = Get-CoverageBadge $branchCoverage
                $methodBadge = Get-CoverageBadge $methodCoverage
                
                $commentBody = @"
                ## ðŸ“Š Code Coverage Report

                | Coverage Type | Percentage | Status |
                |---------------|------------|--------|
                | Line Coverage | ${lineCoverage}% | ${lineBadge} |
                | Branch Coverage | ${branchCoverage}% | ${branchBadge} |
                | Method Coverage | ${methodCoverage}% | ${methodBadge} |

                ### ðŸ“ Coverage by Namespace

                | Namespace | Line Coverage | Branch Coverage | Method Coverage | Classes |
                |-----------|---------------|-----------------|-----------------|---------|

                "@
                
                foreach ($ns in $namespaceStats | Sort-Object Namespace) {
                    $lineBadgeNs = Get-CoverageBadge $ns.LinePercent
                    $branchBadgeNs = Get-CoverageBadge $ns.BranchPercent 
                    $methodBadgeNs = Get-CoverageBadge $ns.MethodPercent
                    
                    $commentBody += "| ``$($ns.Namespace)`` | $($ns.LinePercent)% $lineBadgeNs | $($ns.BranchPercent)% $branchBadgeNs | $($ns.MethodPercent)% $methodBadgeNs | $($ns.ClassCount) |`n"
                }
                
                $commentBody += @"
                
                **Overall Coverage Details:**
                - **Covered Lines:** $($summary.summary.coveredlines) / $($summary.summary.coverablelines)
                - **Covered Branches:** $($summary.summary.coveredbranches) / $($summary.summary.totalbranches) 
                - **Covered Methods:** $($summary.summary.coveredmethods) / $($summary.summary.totalmethods)
                - **Assemblies Tested:** $($summary.summary.assemblies)
                - **Total Classes:** $($summary.summary.classes)
                
                ðŸ“ˆ [View Full Coverage Report]($buildUrl&view=codecoverage-tab)
                
                *Enhanced coverage report with namespace breakdown - Azure DevOps Build #$(Build.BuildNumber)*
                "@
                
                Write-Host "`nGenerated GitHub Comment:"
                Write-Host "========================="
                Write-Host $commentBody
                
                # GitHub API integration
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                try {
                  # Find and update existing coverage comment, or create new one
                  $commentsUri = "https://api.github.com/repos/$repoOwner/$repoName/issues/$prNumber/comments"
                  $existingComments = Invoke-RestMethod -Uri $commentsUri -Headers $headers -Method Get
                  
                  $coverageComment = $existingComments | Where-Object { $_.body -like "*Code Coverage Report*" }
                  
                  $body = @{
                    body = $commentBody
                  } | ConvertTo-Json -Depth 10
                  
                  if ($coverageComment) {
                    # Update existing comment
                    $updateUri = "https://api.github.com/repos/$repoOwner/$repoName/issues/comments/$($coverageComment.id)"
                    $response = Invoke-RestMethod -Uri $updateUri -Method Patch -Headers $headers -Body $body -ContentType 'application/json'
                    Write-Host "Updated existing coverage comment: $($response.html_url)"
                  } else {
                    # Create new comment
                    $response = Invoke-RestMethod -Uri $commentsUri -Method Post -Headers $headers -Body $body -ContentType 'application/json'
                    Write-Host "Created new coverage comment: $($response.html_url)"
                  }
                } catch {
                  Write-Warning "Failed to post coverage comment to GitHub: $_"
                  # Don't fail the build for this
                }

  - stage: Release
    dependsOn: 
    - Build
    condition: and(succeeded(), or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true)))
    displayName: Release
    jobs:
      - job: Release
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - task: DownloadPipelineArtifact@2
            inputs:
              path: $(Build.ArtifactStagingDirectory)
              
          - task: GitHubRelease@1
            inputs:
              gitHubConnection: github.com_rnwood
              repositoryName: rnwood/smtp4dev
              title: $(tag)
              tag: $(tag)
              tagSource: userSpecifiedTag
              releaseNotesSource: inline
              addChangeLog: true
              releaseNotesInline: |
                
                
                [See full installation instructions and options](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md)

                File Name | Description
                -- | --
                [Winget package](https://winget.run/pkg/rnwood/smtp4dev/desktop)| Rnwood.Smtp4dev.Desktop Winget package (recommended easy option for Win10/11)
                [Winget package](https://winget.run/pkg/rnwood/smtp4dev)| Rnwood.Smtp4dev Winget package Win10/11)
                [Rnwood.Smtp4dev-win-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-win-x64-$(tag).zip) | Windows x64 binary standalone - Server edition
                [Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip) | Windows x64 binary standalone - Desktop app edition.
                [Rnwood.Smtp4dev-win-arm64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-win-arm64-$(tag).zip) | Windows ARM 62-bit binary standalone
                [Rnwood.Smtp4dev-linux-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-linux-x64-$(tag).zip) | Linux x64 (Intel 64 bit) binary standalone
                [Rnwood.Smtp4dev-linux-musl-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-linux-musl-x64-$(tag).zip) | Linux MUSL x64 binary standalone for Linux distros using MUSL libc
                [Rnwood.Smtp4dev-noruntime-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-noruntime-$(tag).zip) | Architecture independent version. Should run on any platform where the .NET 8.0 (or greater) runtime is installed
                [Docker images for Windows and Linux](https://hub.docker.com/layers/rnwood/smtp4dev/$(tag)) - [How to use Docker image](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-in-docker)
                [.NET tool Rnwood.Smtp4dev $(tag)](https://www.nuget.org/packages/Rnwood.Smtp4dev/$(tag)) | .NET tool (recommended option for Mac OS) - [How to use dotnet tool](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-as-a-dotnet-global-tool)

 

              ${{ if eq(variables['isreleasebuild'], true) }}:
                action: edit
                isPreRelease: false
                changeLogCompareToRelease: lastFullRelease
              ${{ if not(eq(variables['isreleasebuild'], true)) }}:
                action: create
                isPreRelease: true
                changeLogCompareToRelease: lastNonDraftRelease

              assets: $(Build.ArtifactStagingDirectory)/**/*.zip
          - task: NuGetCommand@2
            inputs:
              command: "push"
              packagesToPush: "$(Build.ArtifactStagingDirectory)/dotnetglobaltool/*.nupkg"
              nuGetFeedType: "external"
              publishFeedCredentials: "nuget_rnwood"
      - job: DockerReleaseTagLinux
        displayName: Docker Release Tag - Linux
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - task: Docker@2
            displayName: Login.
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Tag release
            inputs:
              targetType: inline
              script: | 
                if ([bool]::Parse("$(isreleasebuild)")) {
                    $version = [version] "$(version)"
                    $dockertags = "latest v$($version.Major) v$($version.Major).$($version.Minor)"
                } elseif ([bool]::Parse("$(iscibuild)")) {
                    $dockertags = "prerelease"
                } else {
                    $dockertags = ""
                }
                write-host "Docker tags: $dockertags"

                docker pull $(docker_repo):linux-amd64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-amd64-$_
                  docker push $(docker_repo):linux-amd64-$_
                }

                docker pull $(docker_repo):linux-arm64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):linux-arm64-$(tag) $(docker_repo):linux-arm64-$_
                  docker push $(docker_repo):linux-arm64-$_
                }

      - job: DockerRelease
        displayName: Docker Release
        dependsOn: DockerReleaseTagLinux
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "windows-2022"
        steps:
          - checkout: none
          - task: Docker@2
            displayName: Login
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Tag release
            inputs:
              targetType: inline
              script: |
                if ([bool]::Parse("$(isreleasebuild)")) {
                    $version = [version] "$(version)"
                    $dockertags = "latest v$($version.Major) v$($version.Major).$($version.Minor)"
                } else {
                    $dockertags = "prerelease"
                }
                write-host "Docker tags: $dockertags"
                docker pull $(docker_repo):windows-ltsc2019-amd64-$(tag)
                docker pull $(docker_repo):windows-ltsc2022-amd64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):windows-ltsc2019-amd64-$_
                  docker push $(docker_repo):windows-ltsc2019-amd64-$_
                  docker tag $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):windows-ltsc2022-amd64-$_
                  docker push $(docker_repo):windows-ltsc2022-amd64-$_
                }

                docker manifest create $(docker_repo):$(tag) $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-arm64-$(tag)
                docker manifest push $(docker_repo):$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker manifest create $(docker_repo):$_ $(docker_repo):windows-ltsc2019-amd64-$_ $(docker_repo):windows-ltsc2022-amd64-$_ $(docker_repo):linux-amd64-$_ $(docker_repo):linux-arm64-$_
                  docker manifest push $(docker_repo):$_
                }

  - stage: NotifyOnFailure
    displayName: Notify on Build Failure
    condition: and(failed(), eq(variables['Build.Reason'], 'PullRequest'))
    dependsOn: 
      - Build
    jobs:
      - job: NotifyCopilot
        displayName: Notify Copilot of Build Failure
        pool:
          vmImage: "ubuntu-22.04"
        variables:
          - name: System.Debug
            value: true
        steps:
          - checkout: none
          - task: PowerShell@2
            displayName: Comment on PR to notify Copilot
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: inline
              script: |
                $repoOwner = "rnwood"
                $repoName = "smtp4dev"
                $prNumber = "$(System.PullRequest.PullRequestNumber)"
                $buildUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                $buildId = "$(Build.BuildId)"
                $organizationUri = "$(System.TeamFoundationCollectionUri)"
                $projectName = "$(System.TeamProject)"
                
                # Check if PR is assigned to copilot before proceeding
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                try {
                  $prUri = "https://api.github.com/repos/$repoOwner/$repoName/pulls/$prNumber"
                  $prDetails = Invoke-RestMethod -Uri $prUri -Headers $headers -Method Get
                  
                  # Check if copilot is assigned to this PR
                  $copilotAssigned = $prDetails.assignees | Where-Object { $_.login -eq "copilot" }
                  
                  if (-not $copilotAssigned) {
                    Write-Host "PR #$prNumber is not assigned to @copilot. Skipping notification."
                    exit 0
                  }
                  
                  Write-Host "PR #$prNumber is assigned to @copilot. Proceeding with notification."
                } catch {
                  Write-Error "Failed to check PR assignees: $_"
                  Write-Host "Proceeding with notification as fallback."
                }
                
                # Get build logs using Azure DevOps REST API
                $buildErrors = ""
                try {
                  $azureDevOpsHeaders = @{
                    'Authorization' = "Bearer $env:SYSTEM_ACCESSTOKEN"
                    'Accept' = 'application/json'
                  }
                  
                  # Get build timeline to identify failed tasks
                  $timelineUri = "$organizationUri$projectName/_apis/build/builds/$buildId/timeline?api-version=6.0"
                  $timeline = Invoke-RestMethod -Uri $timelineUri -Headers $azureDevOpsHeaders -Method Get
                  
                  $failedRecords = $timeline.records | Where-Object { $_.result -eq "failed" -and $_.type -eq "Task" }
                  
                  if ($failedRecords) {
                    $buildErrors = "`n`n**Build Error Details:**`n"
                    
                    foreach ($record in $failedRecords) {
                      $buildErrors += "`n**Failed Task: $($record.name)**`n"
                      
                      # Get detailed logs for this task
                      if ($record.log -and $record.log.id) {
                        try {
                          $logUri = "$organizationUri$projectName/_apis/build/builds/$buildId/logs/$($record.log.id)?api-version=6.0"
                          
                          # Get log data - Azure DevOps returns JSON with count and value array
                          $logResponse = Invoke-RestMethod -Uri $logUri -Headers $azureDevOpsHeaders -Method Get
                          
                          Write-Host "Retrieved log data for task $($record.name), count: $($logResponse.count)"
                          Write-Host "Log URI: $logUri"
                          
                          # Extract log lines from the value array
                          $logLines = $logResponse.value
                          
                          Write-Host "Total log lines: $($logLines.Count)"
                          
                          # For failing steps, include ALL output instead of just lines that look like errors
                          # This provides complete context to understand issues like missing files
                          $errorContent = ""
                          $errorCount = 0
                          # Include all log lines, but limit to reasonable size for comment
                          $maxLines = 100  # Limit to last 100 lines to avoid excessively long comments
                          $startIndex = [Math]::Max(0, $logLines.Count - $maxLines)

                          for ($i = $startIndex; $i -lt $logLines.Count; $i++) {
                            $line = $logLines[$i]
                            $trimmedLine = $line.Trim()

                            # Skip empty lines to reduce noise
                            if ($trimmedLine.Length -gt 0) {
                              if ($errorContent -ne "") { $errorContent += [Environment]::NewLine }
                              $errorContent += $trimmedLine
                              $errorCount++
                            }
                          }
                          
                          Write-Host "Including last $errorCount non-empty log lines from failing task"
                          
                          if ($errorCount -gt 0) {
                            $buildErrors += [Environment]::NewLine + '```' + [Environment]::NewLine
                            $buildErrors += $errorContent
                            $buildErrors += [Environment]::NewLine + '```'
                          } else {
                            $buildErrors += [Environment]::NewLine + "No log content available"
                            Write-Host "No log content found for task $($record.name)"
                          }
                        } catch {
                          $buildErrors += "Could not retrieve detailed logs for this task: $($_.Exception.Message)"
                          Write-Host "Error retrieving logs for task $($record.name): $_"
                        }
                      } else {
                        $buildErrors += "No log available for this task."
                      }
                      $buildErrors += "`n"
                    }
                  }
                } catch {
                  Write-Host "Warning: Could not retrieve detailed build logs: $_"
                  $buildErrors = "`n`n**Note:** Detailed error logs could not be retrieved. Please check the build logs manually."
                }
                
                $commentBody = @"
                @copilot The build triggered by this PR has failed. **Please use the error details provided below to investigate and fix the issues. Do not attempt to reproduce the build locally first - consult these error details directly.**
                
                **Build Details:**
                - Build ID: $buildId
                - Build URL: $buildUrl
                - Commit: $(Build.SourceVersion)$buildErrors
                
                **Instructions for @copilot:**
                1. **Analyze the error details above first** - do not try to reproduce the build locally
                2. Focus on the specific compilation errors, test failures, or other issues shown
                3. Make targeted fixes based on the error messages provided
                4. Only build locally after making fixes to verify the solution
                "@
                
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                $body = @{
                  body = $commentBody
                } | ConvertTo-Json -Depth 10
                
                $uri = "https://api.github.com/repos/$repoOwner/$repoName/issues/$prNumber/comments"
                
                try {
                  $response = Invoke-RestMethod -Uri $uri -Method Post -Headers $headers -Body $body -ContentType 'application/json'
                  Write-Host "Successfully posted comment to PR #$prNumber"
                  Write-Host "Comment URL: $($response.html_url)"
                } catch {
                  Write-Error "Failed to post comment to PR #$prNumber : $_"
                  Write-Host "URI: $uri"
                  Write-Host "PR Number: $prNumber"
                  Write-Host "Error Body Length: $($commentBody.Length)"
                  exit 1
                }
