trigger:
  branches:
    include:
      - master
      - refs/tags/*.*.*
      - refs/tags/*.*.*.*
    exclude:
      - refs/tags/*-ci*

pr:
  branches:
    include:
      - master
  paths:
    exclude:
      - docs/*
      - README.md

resources:
  - repo: self

variables:
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    iscibuild: ${{ true }}
    isreleasebuild: ${{ false }}
    isprbuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)) ]
    version: $[ format('{0}{1:yyyyMMdd}{2}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)) ]
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/tags/') }}:
    isreleasebuild: ${{ true }}
    iscibuild: ${{ false }}
    isprbuild: ${{ false }}
    tag: $[ replace(variables['Build.SourceBranch'], 'refs/tags/', '') ]
    version: $[ replace(variables['Build.SourceBranch'], 'refs/tags/', '') ]
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
    isprbuild: ${{ true }}
    iscibuild: ${{ false }}
    isreleasebuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}_pr{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/pull/', ''), '/merge', '')) ]
    version: $[ format('{0}{1:yyyyMMdd}{2}+pr{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/pull/', ''), '/merge', '')) ]
  ${{ else }}:
    isprbuild: ${{ false }}
    isreleasebuild: ${{ false }}
    iscibuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}_{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/heads/', ''), '/', '-')) ] 
    version: $[ format('{0}{1:yyyyMMdd}{2}+{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/heads/', ''), '/', '-')) ] 

    
  docker_repo: "rnwood/smtp4dev"
  docker_registry: "dockerhub-rnwood"
  netcoresdk_version: "10.0.102"
  
  # GitHub API token for PR notifications - should be configured as secret variable
  # GITHUB_TOKEN: $(GITHUB_API_TOKEN)
  # Build includes NuGet and npm package caching for improved performance

stages:
  - stage: Init
    displayName: Init
    jobs:
      - job: Init
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - powershell: |
              Write-Host "IsReleaseBuild=$(isreleasebuild) IsCIBuild=$(iscibuild) isprbuild=$(isprbuild)"
              Write-Host "Tag=$(tag)"
              Write-Host "Version=$(version)"
            displayName: Display build details
          - powershell: Write-Host "##vso[build.updatebuildnumber]$(tag) $(Build.BuildNumber)"
            displayName: Update build details
  - stage: Build
    displayName: Build
    condition: succeeded()
    jobs:
      - job: BuildMatrix
        displayName: Build and test - 
        timeoutInMinutes: 90
        pool:
          vmImage: $(vmImage)
        strategy:
          matrix:
            noruntime:
              platformName: noruntime
              buildArgs: ""
              vmImage: "ubuntu-22.04"
              runTests: ${{ false }}
            win-x64:
              platformName: win-x64
              buildArgs: "-r win-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: "windows-2022"
              runTests: ${{ true }}
            linux-x64:
              platformName: linux-x64
              buildArgs: "-r linux-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: "ubuntu-22.04"
              runTests: ${{ true }}
            # osx-x64:
            #   platformName: osx-x64
            #   buildArgs: "-r osx-x64 --self-contained -p:PublishSingleFile=true"
            #   vmImage: "macOS-11"
            #   runTests: ${{ true }}
            linux-musl-x64:
              platformName: linux-musl-x64
              buildArgs: "-r linux-musl-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: ubuntu-22.04
              runTests: ${{ false }}
            win-arm64:
              platformName: win-arm64
              buildArgs: "-r win-arm64 --self-contained -p:PublishSingleFile=true"
              vmImage: windows-2022
              runTests: ${{ false }}
            linux-arm:
              platformName: linux-arm
              buildArgs: "-r linux-arm --self-contained -p:PublishSingleFile=true"
              vmImage: ubuntu-22.04
              runTests: ${{ false }}
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages based on all project files and solution
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
            condition: ne(variables['Agent.OS'], 'Windows_NT')
          
          # Windows-specific NuGet cache (different default path)
          - task: Cache@2
            displayName: Cache NuGet packages (Windows)
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
            condition: eq(variables['Agent.OS'], 'Windows_NT')
          
          # Cache npm packages based on package-lock.json
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build $(platformName)
            inputs:
              command: build
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              arguments: '-c Release $(buildArgs) -p:version=$(version)'
            env:
              ${{ if ne(variables['Agent.OS'], 'Windows_NT') }}:
                NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          - task: DotNetCoreCLI@2
            displayName: Publish $(platformName)
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              arguments: '-c Release $(buildArgs) -p:version=$(version) -o "$(Build.ArtifactStagingDirectory)/$(platformName)"'
            env:
              ${{ if ne(variables['Agent.OS'], 'Windows_NT') }}:
                NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          - task: ExtractFiles@1
            displayName: Extract files for E2E tests
            condition: and(succeeded(), eq(variables['runTests'], true))
            inputs:
              archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev.zip'
              destinationFolder: $(Agent.TempDirectory)/e2e
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Run SmtpServer Tests
            inputs:
              command: test
              projects: smtpserver/Rnwood.SmtpServer.Tests
              configuration: release
              publishTestResults: true
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Build Test Project for Playwright
            inputs:
              command: build
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '-c Release'

          - task: PowerShell@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Install Playwright Browsers
            timeoutInMinutes: 10
            inputs:
              targetType: inline
              script: |
                Write-Host "Installing Playwright browsers..."
                
                try {
                  Write-Host "Current directory: $(Get-Location)"
                  Write-Host "Starting installation at: $(Get-Date)"
                  
                  # Force a fresh build of the test project to ensure playwright.ps1 is generated
                  Write-Host "Ensuring test project is built with Playwright dependencies..."
                  dotnet build Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj -c Release --no-restore
                  
                  # Wait briefly for file system to sync (CI timing issue)
                  Start-Sleep -Seconds 2
                  
                  # Look for playwright.ps1 script in multiple possible locations
                  $possiblePaths = @(
                    "Rnwood.Smtp4dev.Tests/bin/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/linux-x64/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/win-x64/Release/net8.0/playwright.ps1"
                  )
                  
                  $playwrightScript = $null
                  foreach ($path in $possiblePaths) {
                    Write-Host "Checking for Playwright script at: $path"
                    if (Test-Path $path) {
                      $playwrightScript = $path
                      Write-Host "‚úì Found Playwright script at: $playwrightScript"
                      break
                    }
                  }
                  
                  # If not found in expected locations, search recursively
                  if (-not $playwrightScript) {
                    Write-Host "Script not found in expected locations. Searching recursively..."
                    $foundScripts = Get-ChildItem -Path "." -Name "playwright.ps1" -Recurse -ErrorAction SilentlyContinue
                    if ($foundScripts) {
                      $playwrightScript = $foundScripts[0]
                      Write-Host "‚úì Found Playwright script via recursive search at: $playwrightScript"
                    }
                  }
                  
                  # Debug: Show build output structure if script still not found
                  if (-not $playwrightScript) {
                    Write-Host "‚ùå Playwright script not found. Investigating build output structure..."
                    if (Test-Path "Rnwood.Smtp4dev.Tests/bin") {
                      Write-Host "Contents of Rnwood.Smtp4dev.Tests/bin:"
                      Get-ChildItem "Rnwood.Smtp4dev.Tests/bin" -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
                    } else {
                      Write-Host "Rnwood.Smtp4dev.Tests/bin directory not found"
                      Write-Host "Directory contents at root:"
                      Get-ChildItem "." | ForEach-Object { Write-Host "  $_" }
                    }
                  }
                  
                  if ($playwrightScript -and (Test-Path $playwrightScript)) {
                    Write-Host "Using test project's Playwright script for browser installation..."
                    
                    # Install Chromium browser using project script
                    Write-Host "Installing Chromium browser..."
                    pwsh $playwrightScript install chromium
                    
                    # Install system dependencies on Linux using project script
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      pwsh $playwrightScript install-deps chromium
                    }
                  } else {
                    Write-Host "Falling back to global CLI tool approach..."
                    
                    # Fallback: Use global CLI tool approach as backup
                    Write-Host "Installing global Playwright CLI tool..."
                    dotnet tool install --global Microsoft.Playwright.CLI --version 1.2.3
                    
                    Write-Host "Installing Chromium browser..."
                    playwright install chromium
                    
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      playwright install-deps chromium
                    }
                  }
                  
                  # Verify browser installation
                  Write-Host "Verifying browser installation..."
                  $playwrightCache = if ($IsWindows) { "$env:USERPROFILE\.cache\ms-playwright" } else { "$env:HOME/.cache/ms-playwright" }
                  
                  Write-Host "Checking Playwright cache at: $playwrightCache"
                  if (Test-Path $playwrightCache) {
                    Write-Host "‚úì Playwright cache directory exists"
                    $items = Get-ChildItem $playwrightCache -ErrorAction SilentlyContinue
                    if ($items) {
                      Write-Host "Cache contents:"
                      $items | ForEach-Object { Write-Host "  $_" }
                      
                      $chromiumDirs = $items | Where-Object { $_.Name -like "chromium-*" }
                      if ($chromiumDirs) {
                        Write-Host "‚úì Chromium browser directories found: $($chromiumDirs.Name -join ', ')"
                      } else {
                        Write-Host "Warning: No chromium directories found in cache"
                      }
                    } else {
                      Write-Host "Warning: Playwright cache directory is empty"
                    }
                  } else {
                    Write-Host "Warning: Playwright cache directory not found at: $playwrightCache"
                  }
                  
                  Write-Host "‚úì Playwright installation completed successfully at: $(Get-Date)"
                } catch {
                  Write-Error "Failed to install Playwright: $_"
                  Write-Host "Error details: $($_.Exception.Message)"
                  Write-Host "Error at: $(Get-Date)"
                  exit 1
                }

          - task: PowerShell@2
            condition: and(always(), eq(variables['runTests'], true))
            displayName: Create Playwright Reports Directory (HTML + Traces)
            inputs:
              targetType: inline
              script: |
                # Use Join-Path for cross-platform compatibility
                $tempDir = "$(Agent.TempDirectory)"
                $reportDir = Join-Path $tempDir "playwright-report"
                $tracesDir = Join-Path $reportDir "traces"
                Write-Host "Creating Playwright reports directory: $reportDir"
                Write-Host "Creating Playwright traces directory: $tracesDir"
                Write-Host "Platform: $([Environment]::OSVersion.Platform)"
                Write-Host "Agent.TempDirectory: $tempDir"
                
                if (-not (Test-Path $reportDir)) {
                  New-Item -ItemType Directory -Path $reportDir -Force
                  Write-Host "‚úì Created directory: $reportDir"
                } else {
                  Write-Host "‚úì Directory already exists: $reportDir"
                }
                
                if (-not (Test-Path $tracesDir)) {
                  New-Item -ItemType Directory -Path $tracesDir -Force
                  Write-Host "‚úì Created traces directory: $tracesDir"
                } else {
                  Write-Host "‚úì Traces directory already exists: $tracesDir"
                }
                
                # Verify the directories exist and are accessible
                if (Test-Path $reportDir) {
                  $resolvedPath = Resolve-Path $reportDir
                  Write-Host "‚úì Report directory verified at: $resolvedPath"
                } else {
                  Write-Error "Failed to create or access directory: $reportDir"
                  exit 1
                }
                
                if (Test-Path $tracesDir) {
                  $resolvedTracesPath = Resolve-Path $tracesDir
                  Write-Host "‚úì Traces directory verified at: $resolvedTracesPath"
                } else {
                  Write-Error "Failed to create or access traces directory: $tracesDir"
                  exit 1
                }
                
                # Create an index.html file that includes links to both HTML reports and traces
                $indexHtml = @"
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Playwright E2E Test Results - $(platformName)</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
                        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                        h1 { color: #333; border-bottom: 3px solid #007acc; padding-bottom: 10px; }
                        h2 { color: #555; margin-top: 30px; }
                        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
                        .trace-info { background: #e7f3ff; padding: 15px; margin: 10px 0; border-radius: 5px; }
                        .instructions { background: #fff3cd; padding: 15px; margin: 10px 0; border-radius: 5px; }
                        ul { line-height: 1.6; }
                        .platform { color: #007acc; font-weight: bold; }
                    </style>
                </head>
                <body>
                    <div class='container'>
                        <h1>E2E Test Results - <span class='platform'>$(platformName)</span></h1>
                        <p><strong>Build:</strong> $(Build.BuildNumber) | <strong>Commit:</strong> $(Build.SourceVersion)</p>
                        <p>Generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')</p>
                        
                        <div class='section'>
                            <h2>üîç Playwright Traces</h2>
                            <div class='trace-info'>
                                <p><strong>New Feature:</strong> This build includes comprehensive Playwright traces instead of simple screenshots.</p>
                                <p>Traces provide a complete debugging experience with:</p>
                                <ul>
                                    <li><strong>Screenshots</strong> at every step</li>
                                    <li><strong>DOM snapshots</strong> showing page state</li>
                                    <li><strong>Network activity</strong> and API calls</li>
                                    <li><strong>Console logs</strong> and JavaScript errors</li>
                                    <li><strong>Source code</strong> mapping</li>
                                    <li><strong>Timeline</strong> of all actions</li>
                                </ul>
                            </div>
                            
                            <div class='instructions'>
                                <h3>How to View Traces:</h3>
                                <ol>
                                    <li>Download the <code>PlaywrightReport_$(platformName)</code> artifact from Azure DevOps</li>
                                    <li>Extract the ZIP file</li>
                                    <li>Navigate to the <code>traces/</code> folder</li>
                                    <li>Open any <code>.zip</code> trace file by:
                                        <ul>
                                            <li><strong>Online:</strong> Go to <a href='https://trace.playwright.dev' target='_blank'>trace.playwright.dev</a> and drag the trace ZIP file</li>
                                            <li><strong>CLI:</strong> Run <code>npx playwright show-trace trace-file.zip</code></li>
                                        </ul>
                                    </li>
                                </ol>
                            </div>
                        </div>
                        
                        <div class='section'>
                            <h2>üìä Test Execution Details</h2>
                            <p>E2E tests were executed via <code>dotnet test</code> with Playwright tracing enabled.</p>
                            <p>For test results and detailed logs, check the <strong>Tests</strong> tab in Azure DevOps.</p>
                            <p>Each test that runs generates a corresponding trace file for debugging.</p>
                        </div>
                    </div>
                </body>
                </html>
                "@
                
                $indexPath = Join-Path $reportDir "index.html"
                $indexHtml | Out-File -FilePath $indexPath -Encoding UTF8
                Write-Host "‚úì Created comprehensive HTML report: $indexPath"
                
                # Verify the file was created
                if (Test-Path $indexPath) {
                  Write-Host "‚úì HTML report file verified"
                } else {
                  Write-Error "Failed to create HTML report file: $indexPath"
                  exit 1
                }
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Run Tests
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)/e2e
              SMTP4DEV_E2E_BINARY: $(Agent.TempDirectory)/e2e/Rnwood.Smtp4dev
              # Note: This environment variable is not currently used by our E2E tests
              # Our tests run via dotnet test, not playwright test runner directly
              PLAYWRIGHT_HTML_REPORT: $(Agent.TempDirectory)/playwright-report
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Tests
              configuration: release
              arguments: '--settings:Rnwood.Smtp4dev.Tests/playwright.runsettings'
              publishTestResults: true
          - task: PublishPipelineArtifact@1
            condition: and(always(), eq(variables['runTests'], true))
            displayName: Publish Playwright Reports and Traces
            inputs:
              targetPath: $(Agent.TempDirectory)/playwright-report
              artifact: 'PlaywrightReport_$(platformName)'
              publishLocation: 'pipeline'
          - powershell: move-item $(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev.zip $(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev-$(platformName)-$(tag).zip
            displayName: Rename artifact
          - publish: $(Build.ArtifactStagingDirectory)/$(platformName)
            artifact: $(platformName)
          
            
      - job: BuildGlobalTool
        dependsOn:
        displayName: Build - .NET Global Tool
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build .NET Core Global Tool
            inputs:
              command: custom
              custom: pack
              arguments: '-c Release -p:PackAsTool=true -p:version=$(version) -o "$(Build.ArtifactStagingDirectory)/dotnetglobaltool" Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj'
          - publish: $(Build.ArtifactStagingDirectory)/dotnetglobaltool
            artifact: dotnetglobaltool

      - job: BuildDesktop
        dependsOn:
        displayName: Build - Desktop
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build .NET Core - win-x64-desktop
            inputs:
              command: publish
              projects: "Rnwood.Smtp4dev.Desktop/Rnwood.Smtp4dev.Desktop.csproj"
              publishWebProjects: false
              arguments: '-c Release -r win-x64 -p:version=$(version) --self-contained -p:PublishSingleFile=true -o "$(Build.ArtifactStagingDirectory)/win-x64-desktop"'
          - task: ExtractFiles@1
            displayName: Extract files for E2E tests
            inputs:
              archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop.zip'
              destinationFolder: $(Agent.TempDirectory)/e2e
          - task: DotNetCoreCLI@2
            displayName: Run Tests
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)/e2e
              SMTP4DEV_E2E_BINARY: $(Agent.TempDirectory)/e2e/Rnwood.Smtp4dev.Desktop
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Desktop.Tests
              configuration: release
              publishTestResults: true
          - powershell: move-item $(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop.zip $(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip
            displayName: Rename artifact
          - publish: $(Build.ArtifactStagingDirectory)/win-x64-desktop
            artifact: win-x64-desktop

          # - task: DotNetCoreCLI@2run
          #   displayName: Build .NET Core - linux-x64-desktop
          #   inputs:
          #     command: publish
          #     projects: 'Rnwood.Smtp4dev.Desktop/Rnwood.Smtp4dev.Desktop.csproj'
          #     publishWebProjects: false
          #     arguments: '-c Release -r linux-x64 -p:version=$(version) --self-contained -p:PublishSingleFile=true -o "$(Build.ArtifactStagingDirectory)/linux-x64-desktop"'
          # - powershell: move-item $(Build.ArtifactStagingDirectory)/linux-x64-desktop/Rnwood.Smtp4dev.Desktop.zip $(Build.ArtifactStagingDirectory)/linux-x64-desktop/Rnwood.Smtp4dev.Desktop-linux-x64-$(tag).zip
          #   displayName: Rename artifact
          # - publish: $(Build.ArtifactStagingDirectory)/linux-x64-desktop
          #   artifact: linux-x64-desktop
      - job: DockerBuildLinux
        displayName: DockerBuild - Linux
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -o out'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.linux"
              arguments: "--build-arg version=$(version) -t $(docker_repo):linux-amd64-$(tag)"
          - task: DotNetCoreCLI@2
            displayName: Build Test Project for Playwright
            inputs:
              command: build
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '-c Release'
          - task: PowerShell@2
            displayName: Install Playwright Browsers
            timeoutInMinutes: 10
            inputs:
              targetType: inline
              script: |
                Write-Host "Installing Playwright browsers..."
                
                try {
                  Write-Host "Current directory: $(Get-Location)"
                  Write-Host "Starting installation at: $(Get-Date)"
                  
                  # Wait briefly for file system to sync (CI timing issue)
                  Start-Sleep -Seconds 2
                  
                  # Look for playwright.ps1 script in multiple possible locations
                  $possiblePaths = @(
                    "Rnwood.Smtp4dev.Tests/bin/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/linux-x64/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/win-x64/Release/net8.0/playwright.ps1"
                  )
                  
                  $playwrightScript = $null
                  foreach ($path in $possiblePaths) {
                    Write-Host "Checking for Playwright script at: $path"
                    if (Test-Path $path) {
                      $playwrightScript = $path
                      Write-Host "‚úì Found Playwright script at: $playwrightScript"
                      break
                    }
                  }
                  
                  # If not found in expected locations, search recursively
                  if (-not $playwrightScript) {
                    Write-Host "Script not found in expected locations. Searching recursively..."
                    $foundScripts = Get-ChildItem -Path "." -Name "playwright.ps1" -Recurse -ErrorAction SilentlyContinue
                    if ($foundScripts) {
                      $playwrightScript = $foundScripts[0]
                      Write-Host "‚úì Found Playwright script via recursive search at: $playwrightScript"
                    }
                  }
                  
                  # Debug: Show build output structure if script still not found
                  if (-not $playwrightScript) {
                    Write-Host "‚ùå Playwright script not found. Investigating build output structure..."
                    if (Test-Path "Rnwood.Smtp4dev.Tests/bin") {
                      Write-Host "Contents of Rnwood.Smtp4dev.Tests/bin:"
                      Get-ChildItem "Rnwood.Smtp4dev.Tests/bin" -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
                    } else {
                      Write-Host "Rnwood.Smtp4dev.Tests/bin directory not found"
                      Write-Host "Directory contents at root:"
                      Get-ChildItem "." | ForEach-Object { Write-Host "  $_" }
                    }
                  }
                  
                  if ($playwrightScript -and (Test-Path $playwrightScript)) {
                    Write-Host "Using test project's Playwright script for browser installation..."
                    
                    # Install Chromium browser using project script
                    Write-Host "Installing Chromium browser..."
                    pwsh $playwrightScript install chromium
                    
                    # Install system dependencies on Linux using project script
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      pwsh $playwrightScript install-deps chromium
                    }
                  } else {
                    Write-Host "Falling back to global CLI tool approach..."
                    
                    # Fallback: Use global CLI tool approach as backup
                    Write-Host "Installing global Playwright CLI tool..."
                    dotnet tool install --global Microsoft.Playwright.CLI --version 1.2.3
                    
                    Write-Host "Installing Chromium browser..."
                    playwright install chromium
                    
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      playwright install-deps chromium
                    }
                  }
                  
                  # Verify browser installation
                  Write-Host "Verifying browser installation..."
                  $playwrightCache = if ($IsWindows) { "$env:USERPROFILE\.cache\ms-playwright" } else { "$env:HOME/.cache/ms-playwright" }
                  
                  Write-Host "Checking Playwright cache at: $playwrightCache"
                  if (Test-Path $playwrightCache) {
                    Write-Host "‚úì Playwright cache directory exists"
                    $items = Get-ChildItem $playwrightCache -ErrorAction SilentlyContinue
                    if ($items) {
                      Write-Host "Cache contents:"
                      $items | ForEach-Object { Write-Host "  $_" }
                      
                      $chromiumDirs = $items | Where-Object { $_.Name -like "chromium-*" }
                      if ($chromiumDirs) {
                        Write-Host "‚úì Chromium browser directories found: $($chromiumDirs.Name -join ', ')"
                      } else {
                        Write-Host "Warning: No chromium directories found in cache"
                      }
                    } else {
                      Write-Host "Warning: Playwright cache directory is empty"
                    }
                  } else {
                    Write-Host "Warning: Playwright cache directory not found at: $playwrightCache"
                  }
                  
                  Write-Host "‚úì Playwright installation completed successfully at: $(Get-Date)"
                } catch {
                  Write-Error "Failed to install Playwright: $_"
                  Write-Host "Error details: $($_.Exception.Message)"
                  Write-Host "Error at: $(Get-Date)"
                  exit 1
                }
          - task: DotNetCoreCLI@2
            displayName: Run E2E Tests on Docker Image
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)
              SMTP4DEV_E2E_USEDEFAULTDBPATH: 1
              SMTP4DEV_E2E_BINARY: docker
              SMTP4DEV_E2E_ARGS: |
                run
                -i
                -p
                0:25
                -p
                0:80
                -p
                0:143
                -p
                0:110
                $(docker_repo):linux-amd64-$(tag)
                --urls=http://*:80
                --smtpport=25
                --imapport=143
                --pop3port=110
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '--configuration Release --logger trx'
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                linux-amd64-$(tag)
      - job: DockerBuildLinuxArm64
        displayName: DockerBuild - Linux - ARM64
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -o out'
          - task: CmdLine@2
            displayName: 'Install emulator'
            inputs:
              script: 'sudo apt-get update && sudo apt-get install -y qemu qemu-user-static'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.linux.arm64"
              arguments: "--platform linux/arm64 --build-arg version=$(version) -t $(docker_repo):linux-arm64-$(tag)"
          # E2E tests disabled for ARM64 Docker builds due to QEMU emulation issues
          # The ARM64 image builds successfully, but E2E tests fail intermittently when
          # running ARM64 containers on AMD64 hosts via QEMU emulation. This is a known
          # limitation of QEMU + .NET 10 JIT interaction, not an application defect.
          # All native platforms (including ARM) pass E2E tests successfully.
          # - task: DotNetCoreCLI@2
          #   displayName: Build Test Project
          #   inputs:
          #     command: build
          #     projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
          #     arguments: '-c Release'
          # - task: DotNetCoreCLI@2
          #   displayName: Run E2E Tests on Docker Image
          #   env:
          #     SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)
          #     SMTP4DEV_E2E_USEDEFAULTDBPATH: 1
          #     SMTP4DEV_E2E_BINARY: docker
          #     SMTP4DEV_E2E_ARGS: |
          #       run
          #       -i
          #       -p
          #       0:25
          #       -p
          #       0:80
          #       -p
          #       0:143
          #       -p
          #       0:110
          #       $(docker_repo):linux-arm64-$(tag)
          #       --urls=http://*:80
          #       --smtpport=25
          #       --imapport=143
          #       --pop3port=110
          #   inputs:
          #     command: test
          #     projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
          #     arguments: '--configuration Release --logger trx --filter "FullyQualifiedName!~Rnwood.Smtp4dev.Tests.E2E.WebUI"'
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                linux-arm64-$(tag)
      - job: DockerBuildWindows
        displayName: DockerBuild - Windows LTSC 2019
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -r win-x64 --self-contained -o out'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.windows.ltsc2019"
              arguments: "--build-arg version=$(version) -t $(docker_repo):windows-ltsc2019-amd64-$(tag)"
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.windows.ltsc2022"
              arguments: "--build-arg version=$(version) -t $(docker_repo):windows-ltsc2022-amd64-$(tag)"
          - task: DotNetCoreCLI@2
            displayName: Build Test Project for Playwright
            inputs:
              command: build
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '-c Release'
          - task: PowerShell@2
            displayName: Install Playwright Browsers
            timeoutInMinutes: 10
            inputs:
              targetType: inline
              script: |
                Write-Host "Installing Playwright browsers..."
                
                try {
                  Write-Host "Current directory: $(Get-Location)"
                  Write-Host "Starting installation at: $(Get-Date)"
                  
                  # Wait briefly for file system to sync (CI timing issue)
                  Start-Sleep -Seconds 2
                  
                  # Look for playwright.ps1 script in multiple possible locations
                  $possiblePaths = @(
                    "Rnwood.Smtp4dev.Tests/bin/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/linux-x64/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/win-x64/Release/net8.0/playwright.ps1"
                  )
                  
                  $playwrightScript = $null
                  foreach ($path in $possiblePaths) {
                    Write-Host "Checking for Playwright script at: $path"
                    if (Test-Path $path) {
                      $playwrightScript = $path
                      Write-Host "‚úì Found Playwright script at: $playwrightScript"
                      break
                    }
                  }
                  
                  # If not found in expected locations, search recursively
                  if (-not $playwrightScript) {
                    Write-Host "Script not found in expected locations. Searching recursively..."
                    $foundScripts = Get-ChildItem -Path "." -Name "playwright.ps1" -Recurse -ErrorAction SilentlyContinue
                    if ($foundScripts) {
                      $playwrightScript = $foundScripts[0]
                      Write-Host "‚úì Found Playwright script via recursive search at: $playwrightScript"
                    }
                  }
                  
                  # Debug: Show build output structure if script still not found
                  if (-not $playwrightScript) {
                    Write-Host "‚ùå Playwright script not found. Investigating build output structure..."
                    if (Test-Path "Rnwood.Smtp4dev.Tests/bin") {
                      Write-Host "Contents of Rnwood.Smtp4dev.Tests/bin:"
                      Get-ChildItem "Rnwood.Smtp4dev.Tests/bin" -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
                    } else {
                      Write-Host "Rnwood.Smtp4dev.Tests/bin directory not found"
                      Write-Host "Directory contents at root:"
                      Get-ChildItem "." | ForEach-Object { Write-Host "  $_" }
                    }
                  }
                  
                  if ($playwrightScript -and (Test-Path $playwrightScript)) {
                    Write-Host "Using test project's Playwright script for browser installation..."
                    
                    # Install Chromium browser using project script
                    Write-Host "Installing Chromium browser..."
                    pwsh $playwrightScript install chromium
                    
                    # Install system dependencies on Linux using project script
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      pwsh $playwrightScript install-deps chromium
                    }
                  } else {
                    Write-Host "Falling back to global CLI tool approach..."
                    
                    # Fallback: Use global CLI tool approach as backup
                    Write-Host "Installing global Playwright CLI tool..."
                    dotnet tool install --global Microsoft.Playwright.CLI --version 1.2.3
                    
                    Write-Host "Installing Chromium browser..."
                    playwright install chromium
                    
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      playwright install-deps chromium
                    }
                  }
                  
                  # Verify browser installation
                  Write-Host "Verifying browser installation..."
                  $playwrightCache = if ($IsWindows) { "$env:USERPROFILE\.cache\ms-playwright" } else { "$env:HOME/.cache/ms-playwright" }
                  
                  Write-Host "Checking Playwright cache at: $playwrightCache"
                  if (Test-Path $playwrightCache) {
                    Write-Host "‚úì Playwright cache directory exists"
                    $items = Get-ChildItem $playwrightCache -ErrorAction SilentlyContinue
                    if ($items) {
                      Write-Host "Cache contents:"
                      $items | ForEach-Object { Write-Host "  $_" }
                      
                      $chromiumDirs = $items | Where-Object { $_.Name -like "chromium-*" }
                      if ($chromiumDirs) {
                        Write-Host "‚úì Chromium browser directories found: $($chromiumDirs.Name -join ', ')"
                      } else {
                        Write-Host "Warning: No chromium directories found in cache"
                      }
                    } else {
                      Write-Host "Warning: Playwright cache directory is empty"
                    }
                  } else {
                    Write-Host "Warning: Playwright cache directory not found at: $playwrightCache"
                  }
                  
                  Write-Host "‚úì Playwright installation completed successfully at: $(Get-Date)"
                } catch {
                  Write-Error "Failed to install Playwright: $_"
                  Write-Host "Error details: $($_.Exception.Message)"
                  Write-Host "Error at: $(Get-Date)"
                  exit 1
                }
          - task: DotNetCoreCLI@2
            displayName: Run E2E Tests on Docker Image
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)
              SMTP4DEV_E2E_USEDEFAULTDBPATH: 1
              SMTP4DEV_E2E_BINARY: docker
              SMTP4DEV_E2E_ARGS: |
                run
                -i
                -p
                0:25
                -p
                0:80
                -p
                0:143
                -p
                0:110
                $(docker_repo):windows-ltsc2022-amd64-$(tag)
                --urls=http://*:80
                --smtpport=25
                --imapport=143
                --pop3port=110
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '--configuration Release --logger trx'
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                windows-ltsc2019-amd64-$(tag)
                windows-ltsc2022-amd64-$(tag)
      - job: DockerManifest
        displayName: Docker Create Manifest
        condition: and(or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true)), succeeded('DockerBuildLinux'), succeeded('DockerBuildLinuxArm64'), succeeded('DockerBuildWindows'))

        dependsOn:
          - DockerBuildLinux
          - DockerBuildLinuxArm64
          - DockerBuildWindows
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "windows-2022"
        steps:
          - task: Docker@2
            displayName: Login.
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Create cross platform manifest
            inputs:
              targetType: inline
              script: |
                docker manifest create $(docker_repo):$(tag) $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-arm64-$(tag)
                docker manifest push $(docker_repo):$(tag)
   
  - stage: Release
    dependsOn: 
    - Build
    condition: and(succeeded(), or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true)))
    displayName: Release
    jobs:
      - job: Release
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - task: DownloadPipelineArtifact@2
            inputs:
              path: $(Build.ArtifactStagingDirectory)
              
          - task: GitHubRelease@1
            inputs:
              gitHubConnection: github.com_rnwood
              repositoryName: rnwood/smtp4dev
              title: $(tag)
              tag: $(tag)
              tagSource: userSpecifiedTag
              releaseNotesSource: inline
              addChangeLog: true
              releaseNotesInline: |
                
                
                [See full installation instructions and options](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md)

                File Name | Description
                -- | --
                [Winget package](https://winget.run/pkg/rnwood/smtp4dev/desktop)| Rnwood.Smtp4dev.Desktop Winget package (recommended easy option for Win10/11)
                [Winget package](https://winget.run/pkg/rnwood/smtp4dev)| Rnwood.Smtp4dev Winget package (Win10/11)
                [Rnwood.Smtp4dev-win-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-win-x64-$(tag).zip) | Windows x64 binary standalone - Server edition
                [Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip) | Windows x64 binary standalone - Desktop app edition.
                [Rnwood.Smtp4dev-win-arm64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-win-arm64-$(tag).zip) | Windows ARM 64-bit binary standalone
                [Rnwood.Smtp4dev-linux-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-linux-x64-$(tag).zip) | Linux x64 (Intel 64 bit) binary standalone
                [Rnwood.Smtp4dev-linux-musl-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-linux-musl-x64-$(tag).zip) | Linux MUSL x64 binary standalone for Linux distros using MUSL libc
                [Rnwood.Smtp4dev-noruntime-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-noruntime-$(tag).zip) | Architecture independent version. Should run on any platform where the .NET 8.0 (or greater) runtime is installed
                [Docker images for Windows and Linux](https://hub.docker.com/layers/rnwood/smtp4dev/$(tag)) - [How to use Docker image](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-in-docker)
                [.NET tool Rnwood.Smtp4dev $(tag)](https://www.nuget.org/packages/Rnwood.Smtp4dev/$(tag)) | .NET tool (recommended option for Mac OS) - [How to use dotnet tool](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-as-a-dotnet-global-tool)

 

              ${{ if eq(variables['isreleasebuild'], true) }}:
                action: edit
                isPreRelease: false
                changeLogCompareToRelease: lastFullRelease
              ${{ if not(eq(variables['isreleasebuild'], true)) }}:
                action: create
                isPreRelease: true
                changeLogCompareToRelease: lastNonDraftRelease

              assets: $(Build.ArtifactStagingDirectory)/**/Rnwood.Smtp4dev*.zip
          - task: NuGetCommand@2
            inputs:
              command: "push"
              packagesToPush: "$(Build.ArtifactStagingDirectory)/dotnetglobaltool/*.nupkg"
              nuGetFeedType: "external"
              publishFeedCredentials: "nuget_rnwood"
      - job: DockerReleaseTagLinux
        displayName: Docker Release Tag - Linux
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - task: Docker@2
            displayName: Login.
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Tag release
            inputs:
              targetType: inline
              script: | 
                if ([bool]::Parse("$(isreleasebuild)")) {
                    $version = [version] "$(version)"
                    $dockertags = "latest v$($version.Major) v$($version.Major).$($version.Minor)"
                } elseif ([bool]::Parse("$(iscibuild)")) {
                    $dockertags = "prerelease"
                } else {
                    $dockertags = ""
                }
                write-host "Docker tags: $dockertags"

                docker pull $(docker_repo):linux-amd64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-amd64-$_
                  docker push $(docker_repo):linux-amd64-$_
                }

                docker pull $(docker_repo):linux-arm64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):linux-arm64-$(tag) $(docker_repo):linux-arm64-$_
                  docker push $(docker_repo):linux-arm64-$_
                }

      - job: DockerRelease
        displayName: Docker Release
        dependsOn: DockerReleaseTagLinux
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "windows-2022"
        steps:
          - checkout: none
          - task: Docker@2
            displayName: Login
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Tag release
            inputs:
              targetType: inline
              script: |
                if ([bool]::Parse("$(isreleasebuild)")) {
                    $version = [version] "$(version)"
                    $dockertags = "latest v$($version.Major) v$($version.Major).$($version.Minor)"
                } else {
                    $dockertags = "prerelease"
                }
                write-host "Docker tags: $dockertags"
                docker pull $(docker_repo):windows-ltsc2019-amd64-$(tag)
                docker pull $(docker_repo):windows-ltsc2022-amd64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):windows-ltsc2019-amd64-$_
                  docker push $(docker_repo):windows-ltsc2019-amd64-$_
                  docker tag $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):windows-ltsc2022-amd64-$_
                  docker push $(docker_repo):windows-ltsc2022-amd64-$_
                }

                docker manifest create $(docker_repo):$(tag) $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-arm64-$(tag)
                docker manifest push $(docker_repo):$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker manifest create $(docker_repo):$_ $(docker_repo):windows-ltsc2019-amd64-$_ $(docker_repo):windows-ltsc2022-amd64-$_ $(docker_repo):linux-amd64-$_ $(docker_repo):linux-arm64-$_
                  docker manifest push $(docker_repo):$_
                }

  - stage: NotifyOnFailure
    displayName: Notify on Build Failure
    condition: and(failed(), eq(variables['Build.Reason'], 'PullRequest'))
    dependsOn: 
      - Build
    jobs:
      - job: NotifyCopilot
        displayName: Notify Copilot of Build Failure
        pool:
          vmImage: "ubuntu-22.04"
        variables:
          - name: System.Debug
            value: true
        steps:
          - checkout: none
          - task: PowerShell@2
            displayName: Comment on PR to notify Copilot
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: inline
              script: |
                $repoOwner = "rnwood"
                $repoName = "smtp4dev"
                $prNumber = "$(System.PullRequest.PullRequestNumber)"
                $buildUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                $buildId = "$(Build.BuildId)"
                $organizationUri = "$(System.TeamFoundationCollectionUri)"
                $projectName = "$(System.TeamProject)"
                
                # Check if PR is assigned to copilot before proceeding
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                try {
                  $prUri = "https://api.github.com/repos/$repoOwner/$repoName/pulls/$prNumber"
                  $prDetails = Invoke-RestMethod -Uri $prUri -Headers $headers -Method Get
                  
                  # Check if copilot is assigned to this PR
                  $copilotAssigned = $prDetails.assignees | Where-Object { $_.login -eq "copilot" }
                  
                  if (-not $copilotAssigned) {
                    Write-Host "PR #$prNumber is not assigned to @copilot. Skipping notification."
                    exit 0
                  }
                  
                  Write-Host "PR #$prNumber is assigned to @copilot. Proceeding with notification."
                } catch {
                  Write-Error "Failed to check PR assignees: $_"
                  Write-Host "Proceeding with notification as fallback."
                }
                
                # Note: We no longer extract detailed build logs here to reduce comment size
                # and encourage @copilot to access the live build data directly from Azure DevOps
                
                $commentBody = @"
                @copilot The build triggered by this PR has failed. **Please use the Azure DevOps REST API to investigate and fix the issues.**
                
                **üö® IMPORTANT: Only proceed if this is the most recent commit on your branch. If a newer commit exists, ignore this notification.**
                
                **Build Details:**
                - Build ID: $buildId
                - Build URL: $buildUrl (for reference)
                - Commit: $("$(System.PullRequest.SourceCommitId)".Substring(0, 7))
                - Build Status: FAILED
                
                **Instructions for @copilot:**
                1. **First verify this is the latest commit** - If $("$(System.PullRequest.SourceCommitId)".Substring(0, 7)) is not the most recent commit in this PR branch, ignore this notification
                2. **Use Azure DevOps REST API to get build details and failures:**
                   ```bash
                   # Get build overview
                   curl -s "https://dev.azure.com/rnwood/smtp4dev/_apis/build/builds/$buildId?api-version=6.0" | jq '{status: .status, result: .result, sourceVersion: .sourceVersion}'
                   
                   # Get failed tasks and their logs
                   curl -s "https://dev.azure.com/rnwood/smtp4dev/_apis/build/builds/$buildId/timeline?api-version=6.0" | jq '.records[] | select(.result == "failed") | {name: .name, task: .task.name, errorCount: .errorCount, logId: .log.id}'
                   
                   # Get specific error details from a failed task log (replace LOG_ID)
                   curl -s "https://dev.azure.com/rnwood/smtp4dev/_apis/build/builds/$buildId/logs/LOG_ID" | grep -i "error\|failed"
                   ```
                3. **Analyze the error messages** from the API responses to identify compilation errors, test failures, or other issues
                4. **Make targeted fixes** based on the specific error messages found
                5. **Build locally** after making fixes to verify the solution
                
                **The Azure DevOps REST API provides comprehensive build failure information without requiring browser access.**
                "@
                
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                $body = @{
                  body = $commentBody
                } | ConvertTo-Json -Depth 10
                
                $uri = "https://api.github.com/repos/$repoOwner/$repoName/issues/$prNumber/comments"
                
                try {
                  $response = Invoke-RestMethod -Uri $uri -Method Post -Headers $headers -Body $body -ContentType 'application/json'
                  Write-Host "Successfully posted comment to PR #$prNumber"
                  Write-Host "Comment URL: $($response.html_url)"
                } catch {
                  Write-Error "Failed to post comment to PR #$prNumber : $_"
                  Write-Host "URI: $uri"
                  Write-Host "PR Number: $prNumber"
                  Write-Host "Error Body Length: $($commentBody.Length)"
                  exit 1
                }
