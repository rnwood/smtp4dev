trigger:
  branches:
    include:
      - master
      - refs/tags/*.*.*
      - refs/tags/*.*.*.*
    exclude:
      - refs/tags/*-ci*

pr:
  branches:
    include:
      - master
  paths:
    exclude:
      - docs/*
      - README.md

resources:
  - repo: self

variables:
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    iscibuild: ${{ true }}
    isreleasebuild: ${{ false }}
    isprbuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)) ]
    version: $[ format('{0}{1:yyyyMMdd}{2}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)) ]
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/tags/') }}:
    isreleasebuild: ${{ true }}
    iscibuild: ${{ false }}
    isprbuild: ${{ false }}
    tag: $[ replace(variables['Build.SourceBranch'], 'refs/tags/', '') ]
    version: $[ replace(variables['Build.SourceBranch'], 'refs/tags/', '') ]
  ${{ elseif startsWith(variables['Build.SourceBranch'], 'refs/pull/') }}:
    isprbuild: ${{ true }}
    iscibuild: ${{ false }}
    isreleasebuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}_pr{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/pull/', ''), '/merge', '')) ]
    version: $[ format('{0}{1:yyyyMMdd}{2}+pr{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/pull/', ''), '/merge', '')) ]
  ${{ else }}:
    isprbuild: ${{ false }}
    isreleasebuild: ${{ false }}
    iscibuild: ${{ false }}
    tag: $[ format('{0}{1:yyyyMMdd}{2}_{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/heads/', ''), '/', '-')) ] 
    version: $[ format('{0}{1:yyyyMMdd}{2}+{3}', variables['CIBUILDVERSIONPREFIX'], pipeline.startTime, counter(format('{0:yyyyMMdd}', pipeline.startTime), 100), replace(replace(variables['Build.SourceBranch'], 'refs/heads/', ''), '/', '-')) ] 

    
  docker_repo: "rnwood/smtp4dev"
  docker_registry: "dockerhub-rnwood"
  netcoresdk_version: "8.0.201"
  
  # GitHub API token for PR notifications - should be configured as secret variable
  # GITHUB_TOKEN: $(GITHUB_API_TOKEN)
  # Build includes NuGet and npm package caching for improved performance

stages:
  - stage: Init
    displayName: Init
    jobs:
      - job: Init
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - powershell: |
              Write-Host "IsReleaseBuild=$(isreleasebuild) IsCIBuild=$(iscibuild) isprbuild=$(isprbuild)"
              Write-Host "Tag=$(tag)"
              Write-Host "Version=$(version)"
            displayName: Display build details
          - powershell: Write-Host "##vso[build.updatebuildnumber]$(tag) $(Build.BuildNumber)"
            displayName: Update build details
  - stage: Build
    displayName: Build
    condition: succeeded()
    jobs:
      - job: BuildMatrix
        displayName: Build and test - 
        timeoutInMinutes: 90
        pool:
          vmImage: $(vmImage)
        strategy:
          matrix:
            noruntime:
              platformName: noruntime
              buildArgs: ""
              vmImage: "ubuntu-22.04"
              runTests: ${{ false }}
            win-x64:
              platformName: win-x64
              buildArgs: "-r win-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: "windows-2022"
              runTests: ${{ true }}
            linux-x64:
              platformName: linux-x64
              buildArgs: "-r linux-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: "ubuntu-22.04"
              runTests: ${{ true }}
            # osx-x64:
            #   platformName: osx-x64
            #   buildArgs: "-r osx-x64 --self-contained -p:PublishSingleFile=true"
            #   vmImage: "macOS-11"
            #   runTests: ${{ true }}
            linux-musl-x64:
              platformName: linux-musl-x64
              buildArgs: "-r linux-musl-x64 --self-contained -p:PublishSingleFile=true"
              vmImage: ubuntu-22.04
              runTests: ${{ false }}
            win-arm64:
              platformName: win-arm64
              buildArgs: "-r win-arm64 --self-contained -p:PublishSingleFile=true"
              vmImage: windows-2022
              runTests: ${{ false }}
            linux-arm:
              platformName: linux-arm
              buildArgs: "-r linux-arm --self-contained -p:PublishSingleFile=true"
              vmImage: ubuntu-22.04
              runTests: ${{ false }}
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages based on all project files and solution
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
            condition: ne(variables['Agent.OS'], 'Windows_NT')
          
          # Windows-specific NuGet cache (different default path)
          - task: Cache@2
            displayName: Cache NuGet packages (Windows)
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
            condition: eq(variables['Agent.OS'], 'Windows_NT')
          
          # Cache npm packages based on package-lock.json
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build $(platformName)
            inputs:
              command: build
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              arguments: '-c Release $(buildArgs) -p:version=$(version)'
            env:
              ${{ if ne(variables['Agent.OS'], 'Windows_NT') }}:
                NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          - task: DotNetCoreCLI@2
            displayName: Publish $(platformName)
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              arguments: '-c Release $(buildArgs) -p:version=$(version) -o "$(Build.ArtifactStagingDirectory)/$(platformName)"'
            env:
              ${{ if ne(variables['Agent.OS'], 'Windows_NT') }}:
                NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
          - task: ExtractFiles@1
            displayName: Extract files for E2E tests
            condition: and(succeeded(), eq(variables['runTests'], true))
            inputs:
              archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev.zip'
              destinationFolder: $(Agent.TempDirectory)/e2e
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Run SmtpServer Tests
            inputs:
              command: test
              projects: smtpserver/Rnwood.SmtpServer.Tests
              configuration: release
              arguments: '--collect:"XPlat Code Coverage"'
              publishTestResults: true
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Build Test Project for Playwright
            inputs:
              command: build
              projects: Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj
              arguments: '-c Release'

          - task: PowerShell@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Install Playwright Browsers with Robust Detection
            timeoutInMinutes: 10
            inputs:
              targetType: inline
              script: |
                Write-Host "Installing Playwright browsers with robust detection..."
                
                try {
                  Write-Host "Current directory: $(Get-Location)"
                  Write-Host "Starting installation at: $(Get-Date)"
                  
                  # Force a fresh build of the test project to ensure playwright.ps1 is generated
                  Write-Host "Ensuring test project is built with Playwright dependencies..."
                  dotnet build Rnwood.Smtp4dev.Tests/Rnwood.Smtp4dev.Tests.csproj -c Release --no-restore
                  
                  # Wait briefly for file system to sync (CI timing issue)
                  Start-Sleep -Seconds 2
                  
                  # Look for playwright.ps1 script in multiple possible locations
                  $possiblePaths = @(
                    "Rnwood.Smtp4dev.Tests/bin/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/linux-x64/Release/net8.0/playwright.ps1",
                    "Rnwood.Smtp4dev.Tests/bin/win-x64/Release/net8.0/playwright.ps1"
                  )
                  
                  $playwrightScript = $null
                  foreach ($path in $possiblePaths) {
                    Write-Host "Checking for Playwright script at: $path"
                    if (Test-Path $path) {
                      $playwrightScript = $path
                      Write-Host "‚úì Found Playwright script at: $playwrightScript"
                      break
                    }
                  }
                  
                  # If not found in expected locations, search recursively
                  if (-not $playwrightScript) {
                    Write-Host "Script not found in expected locations. Searching recursively..."
                    $foundScripts = Get-ChildItem -Path "." -Name "playwright.ps1" -Recurse -ErrorAction SilentlyContinue
                    if ($foundScripts) {
                      $playwrightScript = $foundScripts[0]
                      Write-Host "‚úì Found Playwright script via recursive search at: $playwrightScript"
                    }
                  }
                  
                  # Debug: Show build output structure if script still not found
                  if (-not $playwrightScript) {
                    Write-Host "‚ùå Playwright script not found. Investigating build output structure..."
                    if (Test-Path "Rnwood.Smtp4dev.Tests/bin") {
                      Write-Host "Contents of Rnwood.Smtp4dev.Tests/bin:"
                      Get-ChildItem "Rnwood.Smtp4dev.Tests/bin" -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
                    } else {
                      Write-Host "Rnwood.Smtp4dev.Tests/bin directory not found"
                      Write-Host "Directory contents at root:"
                      Get-ChildItem "." | ForEach-Object { Write-Host "  $_" }
                    }
                  }
                  
                  if ($playwrightScript -and (Test-Path $playwrightScript)) {
                    Write-Host "Using test project's Playwright script for browser installation..."
                    
                    # Install Chromium browser using project script
                    Write-Host "Installing Chromium browser..."
                    pwsh $playwrightScript install chromium
                    
                    # Install system dependencies on Linux using project script
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      pwsh $playwrightScript install-deps chromium
                    }
                  } else {
                    Write-Host "Falling back to global CLI tool approach..."
                    
                    # Fallback: Use global CLI tool approach as backup
                    Write-Host "Installing global Playwright CLI tool..."
                    dotnet tool install --global Microsoft.Playwright.CLI --version 1.2.3
                    
                    Write-Host "Installing Chromium browser..."
                    playwright install chromium
                    
                    if ($IsLinux) {
                      Write-Host "Installing system dependencies on Linux..."
                      playwright install-deps chromium
                    }
                  }
                  
                  # Verify browser installation
                  Write-Host "Verifying browser installation..."
                  $playwrightCache = if ($IsWindows) { "$env:USERPROFILE\.cache\ms-playwright" } else { "$env:HOME/.cache/ms-playwright" }
                  
                  Write-Host "Checking Playwright cache at: $playwrightCache"
                  if (Test-Path $playwrightCache) {
                    Write-Host "‚úì Playwright cache directory exists"
                    $items = Get-ChildItem $playwrightCache -ErrorAction SilentlyContinue
                    if ($items) {
                      Write-Host "Cache contents:"
                      $items | ForEach-Object { Write-Host "  $_" }
                      
                      $chromiumDirs = $items | Where-Object { $_.Name -like "chromium-*" }
                      if ($chromiumDirs) {
                        Write-Host "‚úì Chromium browser directories found: $($chromiumDirs.Name -join ', ')"
                      } else {
                        Write-Host "Warning: No chromium directories found in cache"
                      }
                    } else {
                      Write-Host "Warning: Playwright cache directory is empty"
                    }
                  } else {
                    Write-Host "Warning: Playwright cache directory not found at: $playwrightCache"
                  }
                  
                  Write-Host "‚úì Playwright installation completed successfully at: $(Get-Date)"
                } catch {
                  Write-Error "Failed to install Playwright: $_"
                  Write-Host "Error details: $($_.Exception.Message)"
                  Write-Host "Error at: $(Get-Date)"
                  exit 1
                }

          - task: PowerShell@2
            condition: and(always(), eq(variables['runTests'], true))
            displayName: Create Playwright HTML Report Directory
            inputs:
              targetType: inline
              script: |
                # Use Join-Path for cross-platform compatibility
                $tempDir = "$(Agent.TempDirectory)"
                $reportDir = Join-Path $tempDir "playwright-report"
                Write-Host "Creating Playwright HTML report directory: $reportDir"
                Write-Host "Platform: $([Environment]::OSVersion.Platform)"
                Write-Host "Agent.TempDirectory: $tempDir"
                
                if (-not (Test-Path $reportDir)) {
                  New-Item -ItemType Directory -Path $reportDir -Force
                  Write-Host "‚úì Created directory: $reportDir"
                } else {
                  Write-Host "‚úì Directory already exists: $reportDir"
                }
                
                # Verify the directory exists and is accessible
                if (Test-Path $reportDir) {
                  $resolvedPath = Resolve-Path $reportDir
                  Write-Host "‚úì Directory verified at: $resolvedPath"
                } else {
                  Write-Error "Failed to create or access directory: $reportDir"
                  exit 1
                }
                
                # Create a minimal index.html file for the report
                $indexHtml = @"
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Playwright Test Results</title>
                </head>
                <body>
                    <h1>E2E Test Results</h1>
                    <p>E2E tests were run via dotnet test. Check the test results in the Azure DevOps test results tab.</p>
                    <p>For detailed logs, refer to the build pipeline output.</p>
                </body>
                </html>
                "@
                
                $indexPath = Join-Path $reportDir "index.html"
                $indexHtml | Out-File -FilePath $indexPath -Encoding UTF8
                Write-Host "‚úì Created basic HTML report: $indexPath"
                
                # Verify the file was created
                if (Test-Path $indexPath) {
                  Write-Host "‚úì HTML report file verified"
                } else {
                  Write-Error "Failed to create HTML report file: $indexPath"
                  exit 1
                }
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Run Tests
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)/e2e
              SMTP4DEV_E2E_BINARY: $(Agent.TempDirectory)/e2e/Rnwood.Smtp4dev
              # Note: This environment variable is not currently used by our E2E tests
              # Our tests run via dotnet test, not playwright test runner directly
              PLAYWRIGHT_HTML_REPORT: $(Agent.TempDirectory)/playwright-report
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Tests
              configuration: release
              arguments: '--collect:"XPlat Code Coverage" --settings:Rnwood.Smtp4dev.Tests/playwright.runsettings'
              publishTestResults: true
          - task: PublishPipelineArtifact@1
            condition: and(always(), eq(variables['runTests'], true))
            displayName: Publish Playwright HTML Report
            inputs:
              targetPath: $(Agent.TempDirectory)/playwright-report
              artifact: 'PlaywrightReport_$(platformName)'
              publishLocation: 'pipeline'
          - task: DotNetCoreCLI@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Install ReportGenerator Tool
            inputs:
              command: custom
              custom: tool
              arguments: 'install --global dotnet-reportgenerator-globaltool'
          - task: PowerShell@2
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Generate Coverage Reports
            inputs:
              targetType: inline
              script: |
                Write-Host "Generating coverage reports..."
                $coverageFiles = Get-ChildItem -Path "$(Agent.TempDirectory)" -Recurse -Include "coverage.cobertura.xml" | ForEach-Object { $_.FullName }
                Write-Host "Found coverage files: $($coverageFiles -join ', ')"
                
                if ($coverageFiles.Count -gt 0) {
                  $reportsArg = $coverageFiles -join ";"
                  $targetDir = "$(Agent.TempDirectory)/CoverageReports"
                  
                  reportgenerator -reports:"$reportsArg" -targetdir:"$targetDir" -reporttypes:"Cobertura;HtmlInline_AzurePipelines;JsonSummary;Badges" -verbosity:Info
                  
                  Write-Host "Coverage reports generated in: $targetDir"
                  
                  # Display summary
                  if (Test-Path "$targetDir/Summary.json") {
                    $summary = Get-Content "$targetDir/Summary.json" | ConvertFrom-Json
                    Write-Host "Line Coverage: $($summary.summary.linecoverage)%"
                    Write-Host "Branch Coverage: $($summary.summary.branchcoverage)%"
                    Write-Host "Method Coverage: $($summary.summary.methodcoverage)%"
                  }
                } else {
                  Write-Host "No coverage files found."
                } 
          - task: PublishCodeCoverageResults@1
            condition: and(succeeded(), eq(variables['runTests'], true))
            displayName: Publish Code Coverage Results
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/CoverageReports/Cobertura.xml'
              reportDirectory: '$(Agent.TempDirectory)/CoverageReports'
              failIfCoverageEmpty: false
          - task: PublishPipelineArtifact@1
            condition: and(succeeded(), eq(variables['runTests'], true), eq(variables['platformName'], 'linux-x64'))
            displayName: Publish Coverage Reports as Artifact
            inputs:
              targetPath: '$(Agent.TempDirectory)/CoverageReports'
              artifact: 'CoverageReports'
              publishLocation: 'pipeline'
          - powershell: move-item $(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev.zip $(Build.ArtifactStagingDirectory)/$(platformName)/Rnwood.Smtp4dev-$(platformName)-$(tag).zip
            displayName: Rename artifact
          - publish: $(Build.ArtifactStagingDirectory)/$(platformName)
            artifact: $(platformName)
          
            
      - job: BuildGlobalTool
        dependsOn:
        displayName: Build - .NET Global Tool
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build .NET Core Global Tool
            inputs:
              command: custom
              custom: pack
              arguments: '-c Release -p:PackAsTool=true -p:version=$(version) -o "$(Build.ArtifactStagingDirectory)/dotnetglobaltool" Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj'
          - publish: $(Build.ArtifactStagingDirectory)/dotnetglobaltool
            artifact: dotnetglobaltool

      - job: BuildDesktop
        dependsOn:
        displayName: Build - Desktop
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Build .NET Core - win-x64-desktop
            inputs:
              command: publish
              projects: "Rnwood.Smtp4dev.Desktop/Rnwood.Smtp4dev.Desktop.csproj"
              publishWebProjects: false
              arguments: '-c Release -r win-x64 -p:version=$(version) --self-contained -p:PublishSingleFile=true -o "$(Build.ArtifactStagingDirectory)/win-x64-desktop"'
          - task: ExtractFiles@1
            displayName: Extract files for E2E tests
            inputs:
              archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop.zip'
              destinationFolder: $(Agent.TempDirectory)/e2e
          - task: DotNetCoreCLI@2
            displayName: Run Tests
            env:
              SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)/e2e
              SMTP4DEV_E2E_BINARY: $(Agent.TempDirectory)/e2e/Rnwood.Smtp4dev.Desktop
            inputs:
              command: test
              projects: Rnwood.Smtp4dev.Desktop.Tests
              configuration: release
              arguments: '--collect:"XPlat Code Coverage"'
              publishTestResults: true
          - powershell: move-item $(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop.zip $(Build.ArtifactStagingDirectory)/win-x64-desktop/Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip
            displayName: Rename artifact
          - publish: $(Build.ArtifactStagingDirectory)/win-x64-desktop
            artifact: win-x64-desktop

          # - task: DotNetCoreCLI@2run
          #   displayName: Build .NET Core - linux-x64-desktop
          #   inputs:
          #     command: publish
          #     projects: 'Rnwood.Smtp4dev.Desktop/Rnwood.Smtp4dev.Desktop.csproj'
          #     publishWebProjects: false
          #     arguments: '-c Release -r linux-x64 -p:version=$(version) --self-contained -p:PublishSingleFile=true -o "$(Build.ArtifactStagingDirectory)/linux-x64-desktop"'
          # - powershell: move-item $(Build.ArtifactStagingDirectory)/linux-x64-desktop/Rnwood.Smtp4dev.Desktop.zip $(Build.ArtifactStagingDirectory)/linux-x64-desktop/Rnwood.Smtp4dev.Desktop-linux-x64-$(tag).zip
          #   displayName: Rename artifact
          # - publish: $(Build.ArtifactStagingDirectory)/linux-x64-desktop
          #   artifact: linux-x64-desktop
      - job: DockerBuildLinux
        displayName: DockerBuild - Linux
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -o out'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.linux"
              arguments: "--build-arg version=$(version) -t $(docker_repo):linux-amd64-$(tag)"
          # - task: DotNetCoreCLI@2
          #   displayName: Run Tests
          #   env:
          #     SMTP4DEV_E2E_WORKINGDIR: $(Agent.TempDirectory)
          #     SMTP4DEV_E2E_USEDEFAULTDBPATH: 1
          #     SMTP4DEV_E2E_BINARY: docker
          #     SMTP4DEV_E2E_ARGS: |
          #       run
          #       -i
          #       -p
          #       25:25
          #       -p
          #       80:80
          #       -p
          #       110:110
          #       $(docker_repo):linux-amd64-$(tag)
          #       --urls=http://*:80
          #       --smtpport=25
          #       --imapport=110
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                linux-amd64-$(tag)
      - job: DockerBuildLinuxArm64
        displayName: DockerBuild - Linux - ARM64
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.nuget/packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -o out'
          - task: CmdLine@2
            displayName: 'Install emulator'
            inputs:
              script: 'sudo apt-get update && sudo apt-get install -y qemu qemu-user-static'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.linux.arm64"
              arguments: "--platform linux/arm64 --build-arg version=$(version) -t $(docker_repo):linux-arm64-$(tag)"
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                linux-arm64-$(tag)
      - job: DockerBuildWindows
        displayName: DockerBuild - Windows LTSC 2019
        pool:
          vmImage: "windows-2022"
        steps:
          - task: UseDotNet@2
            displayName: Install .NET Core SDK v$(netcoresdk_version)
            inputs:
              packageType: sdk
              version: $(netcoresdk_version)
          
          # Cache NuGet packages for Windows
          - task: Cache@2
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | "$(netcoresdk_version)" | **/*.csproj'
              restoreKeys: |
                nuget | "$(Agent.OS)" | "$(netcoresdk_version)"
                nuget | "$(Agent.OS)"
              path: $(UserProfile)\.nuget\packages
          
          # Cache npm packages
          - task: Cache@2
            displayName: Cache npm packages
            inputs:
              key: 'npm | "$(Agent.OS)" | Rnwood.Smtp4dev/ClientApp/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: Rnwood.Smtp4dev/ClientApp/node_modules
          - task: DotNetCoreCLI@2
            displayName: Publish
            inputs:
              command: publish
              projects: Rnwood.Smtp4dev/Rnwood.Smtp4dev.csproj
              publishWebProjects: false
              zipAfterPublish: false
              modifyOutputPath: false
              arguments: '-c Release -p:version=$(version) -r win-x64 --self-contained -o out'
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.windows.ltsc2019"
              arguments: "--build-arg version=$(version) -t $(docker_repo):windows-ltsc2019-amd64-$(tag)"
          - task: Docker@2
            displayName: Build image
            inputs:
              command: build
              dockerfile: "**/Dockerfile.windows.ltsc2022"
              arguments: "--build-arg version=$(version) -t $(docker_repo):windows-ltsc2022-amd64-$(tag)"
          - task: Docker@2
            displayName: Push image
            condition: or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true))
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: push
              tags: |
                windows-ltsc2019-amd64-$(tag)
                windows-ltsc2022-amd64-$(tag)
      - job: DockerManifest
        displayName: Docker Create Manifest
        condition: and(or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true)), succeeded('DockerBuildLinux'), succeeded('DockerBuildLinuxArm64'), succeeded('DockerBuildWindows'))

        dependsOn:
          - DockerBuildLinux
          - DockerBuildLinuxArm64
          - DockerBuildWindows
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "windows-2022"
        steps:
          - task: Docker@2
            displayName: Login.
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Create cross platform manifest
            inputs:
              targetType: inline
              script: |
                docker manifest create $(docker_repo):$(tag) $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-arm64-$(tag)
                docker manifest push $(docker_repo):$(tag)
   
  - stage: ReportCoverage
    displayName: Report Coverage to GitHub
    condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))
    dependsOn: 
      - Build
    jobs:
      - job: ReportToGitHub
        displayName: Report Coverage to GitHub
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: self
            fetchDepth: 1
          - task: DownloadPipelineArtifact@2
            displayName: Download Coverage Reports
            inputs:
              buildType: 'current'
              artifactName: 'CoverageReports'
              targetPath: '$(System.DefaultWorkingDirectory)/CoverageReports'
            continueOnError: true
          - task: PowerShell@2
            displayName: Enhanced Coverage Report to PR
            condition: and(succeeded(), ne(variables['GITHUB_TOKEN'], ''))
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
            inputs:
              targetType: inline
              script: |
                $repoOwner = "rnwood"
                $repoName = "smtp4dev"
                $prNumber = "$(System.PullRequest.PullRequestNumber)"
                $buildUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                
                # Check if coverage reports exist
                $summaryFile = "$(System.DefaultWorkingDirectory)/CoverageReports/Summary.json"
                if (-not (Test-Path $summaryFile)) {
                  Write-Host "No coverage summary found. Skipping GitHub coverage report."
                  exit 0
                }
                
                Write-Host "Enhanced Coverage Reporter"
                Write-Host "========================="
                
                # Read coverage summary
                $summary = Get-Content $summaryFile | ConvertFrom-Json
                $lineCoverage = [math]::Round($summary.summary.linecoverage, 1)
                $branchCoverage = [math]::Round($summary.summary.branchcoverage, 1)
                $methodCoverage = [math]::Round($summary.summary.methodcoverage, 1)
                
                Write-Host "Overall Coverage: Line: $lineCoverage%, Branch: $branchCoverage%, Method: $methodCoverage%"
                
                # For now, we don't have base coverage comparison (can be added later)
                # Future enhancement: Download base branch coverage for comparison
                # To implement PR deltas:
                # 1. Get base branch name: $(System.PullRequest.TargetBranch)
                # 2. Download artifact from latest successful build on base branch
                # 3. Compare current vs base coverage using enhanced script logic
                # 4. Add delta columns to namespace table and overall summary
                $showDeltas = $false
                
                # Group classes by namespace
                $namespaceGroups = @{}
                foreach ($assembly in $summary.coverage.assemblies) {
                    foreach ($class in $assembly.classesinassembly) {
                        $className = $class.name
                        
                        # Extract namespace from class name (handle nested classes)
                        $namespace = ""
                        if ($className -match '^([^<]+?)\.([^\.]+)$') {
                            # Simple case: Namespace.ClassName
                            $namespace = $matches[1]
                        } elseif ($className -match '^([^<]+?)\.([^\.]+?)\/') {
                            # Nested class case: Namespace.ClassName/NestedClass  
                            $namespace = $matches[1]
                        } elseif ($className -match '^([^<]+?)\.([^\.]+?)\.([^\.\/]+)$') {
                            # Two-level namespace: Namespace.SubNamespace.ClassName
                            $namespace = $matches[1] + "." + $matches[2]
                        } else {
                            # Fallback - use the part before the last component
                            $parts = $className -split '\.'
                            if ($parts.Length -gt 1) {
                                $namespace = ($parts[0..($parts.Length-2)] -join ".")
                            } else {
                                $namespace = "Global"
                            }
                        }
                        
                        if (-not $namespaceGroups.ContainsKey($namespace)) {
                            $namespaceGroups[$namespace] = @{
                                Classes = @()
                                TotalCoverableLines = 0
                                TotalCoveredLines = 0
                                TotalBranches = 0
                                TotalCoveredBranches = 0
                                TotalMethods = 0
                                TotalCoveredMethods = 0
                                ClassCount = 0
                            }
                        }
                        
                        $namespaceGroups[$namespace].Classes += $class
                        $namespaceGroups[$namespace].TotalCoverableLines += $class.coverablelines
                        $namespaceGroups[$namespace].TotalCoveredLines += $class.coveredlines
                        $namespaceGroups[$namespace].TotalBranches += $class.totalbranches
                        $namespaceGroups[$namespace].TotalCoveredBranches += $class.coveredbranches
                        $namespaceGroups[$namespace].TotalMethods += $class.totalmethods
                        $namespaceGroups[$namespace].TotalCoveredMethods += $class.coveredmethods
                        $namespaceGroups[$namespace].ClassCount += 1
                    }
                }
                
                # Calculate namespace-level coverage percentages
                $namespaceStats = @()
                foreach ($namespace in $namespaceGroups.Keys | Sort-Object) {
                    $group = $namespaceGroups[$namespace]
                    
                    $lineCov = if ($group.TotalCoverableLines -gt 0) { [math]::Round(($group.TotalCoveredLines / $group.TotalCoverableLines) * 100, 1) } else { 0 }
                    $branchCov = if ($group.TotalBranches -gt 0) { [math]::Round(($group.TotalCoveredBranches / $group.TotalBranches) * 100, 1) } else { 0 }
                    $methodCov = if ($group.TotalMethods -gt 0) { [math]::Round(($group.TotalCoveredMethods / $group.TotalMethods) * 100, 1) } else { 0 }
                    
                    $namespaceStats += [PSCustomObject]@{
                        Namespace = $namespace
                        LinePercent = $lineCov
                        BranchPercent = $branchCov
                        MethodPercent = $methodCov
                        ClassCount = $group.ClassCount
                        CoveredLines = $group.TotalCoveredLines
                        CoverableLines = $group.TotalCoverableLines
                        CoveredBranches = $group.TotalCoveredBranches
                        TotalBranches = $group.TotalBranches
                        CoveredMethods = $group.TotalCoveredMethods
                        TotalMethods = $group.TotalMethods
                    }
                }
                
                Write-Host "`nNamespace Coverage Breakdown:"
                Write-Host "============================="
                foreach ($ns in $namespaceStats) {
                    Write-Host "$($ns.Namespace): Line: $($ns.LinePercent)%, Branch: $($ns.BranchPercent)%, Method: $($ns.MethodPercent)% ($($ns.ClassCount) classes)"
                }
                
                # Generate enhanced GitHub comment
                function Get-CoverageBadge($percentage) {
                    if ($percentage -ge 80) { return "üü¢" }
                    elseif ($percentage -ge 60) { return "üü°" }
                    else { return "üî¥" }
                }
                
                $lineBadge = Get-CoverageBadge $lineCoverage
                $branchBadge = Get-CoverageBadge $branchCoverage
                $methodBadge = Get-CoverageBadge $methodCoverage
                
                $commentBody = @"
                ## üìä Code Coverage Report

                | Coverage Type | Percentage | Status |
                |---------------|------------|--------|
                | Line Coverage | ${lineCoverage}% | ${lineBadge} |
                | Branch Coverage | ${branchCoverage}% | ${branchBadge} |
                | Method Coverage | ${methodCoverage}% | ${methodBadge} |

                ### üìÅ Coverage by Namespace

                | Namespace | Line Coverage | Branch Coverage | Method Coverage | Classes |
                |-----------|---------------|-----------------|-----------------|---------|

                "@
                
                foreach ($ns in $namespaceStats | Sort-Object Namespace) {
                    $lineBadgeNs = Get-CoverageBadge $ns.LinePercent
                    $branchBadgeNs = Get-CoverageBadge $ns.BranchPercent 
                    $methodBadgeNs = Get-CoverageBadge $ns.MethodPercent
                    
                    $commentBody += "| ``$($ns.Namespace)`` | $($ns.LinePercent)% $lineBadgeNs | $($ns.BranchPercent)% $branchBadgeNs | $($ns.MethodPercent)% $methodBadgeNs | $($ns.ClassCount) |`n"
                }
                
                $commentBody += @"
                
                **Overall Coverage Details:**
                - **Covered Lines:** $($summary.summary.coveredlines) / $($summary.summary.coverablelines)
                - **Covered Branches:** $($summary.summary.coveredbranches) / $($summary.summary.totalbranches) 
                - **Covered Methods:** $($summary.summary.coveredmethods) / $($summary.summary.totalmethods)
                - **Assemblies Tested:** $($summary.summary.assemblies)
                - **Total Classes:** $($summary.summary.classes)
                
                üìà [View Full Coverage Report]($buildUrl&view=codecoverage-tab)
                
                *Enhanced coverage report with namespace breakdown - Azure DevOps Build #$(Build.BuildNumber)*
                "@
                
                Write-Host "`nGenerated GitHub Comment:"
                Write-Host "========================="
                Write-Host $commentBody
                
                # GitHub API integration
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                try {
                  # Find and update existing coverage comment, or create new one
                  $commentsUri = "https://api.github.com/repos/$repoOwner/$repoName/issues/$prNumber/comments"
                  $existingComments = Invoke-RestMethod -Uri $commentsUri -Headers $headers -Method Get
                  
                  $coverageComment = $existingComments | Where-Object { $_.body -like "*Code Coverage Report*" }
                  
                  $body = @{
                    body = $commentBody
                  } | ConvertTo-Json -Depth 10
                  
                  if ($coverageComment) {
                    # Update existing comment
                    $updateUri = "https://api.github.com/repos/$repoOwner/$repoName/issues/comments/$($coverageComment.id)"
                    $response = Invoke-RestMethod -Uri $updateUri -Method Patch -Headers $headers -Body $body -ContentType 'application/json'
                    Write-Host "Updated existing coverage comment: $($response.html_url)"
                  } else {
                    # Create new comment
                    $response = Invoke-RestMethod -Uri $commentsUri -Method Post -Headers $headers -Body $body -ContentType 'application/json'
                    Write-Host "Created new coverage comment: $($response.html_url)"
                  }
                } catch {
                  Write-Warning "Failed to post coverage comment to GitHub: $_"
                  # Don't fail the build for this
                }

  - stage: Release
    dependsOn: 
    - Build
    condition: and(succeeded(), or(eq(variables['isreleasebuild'], true), eq(variables['iscibuild'], true), eq(variables['isprbuild'], true)))
    displayName: Release
    jobs:
      - job: Release
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - task: DownloadPipelineArtifact@2
            inputs:
              path: $(Build.ArtifactStagingDirectory)
              
          - task: GitHubRelease@1
            inputs:
              gitHubConnection: github.com_rnwood
              repositoryName: rnwood/smtp4dev
              title: $(tag)
              tag: $(tag)
              tagSource: userSpecifiedTag
              releaseNotesSource: inline
              addChangeLog: true
              releaseNotesInline: |
                
                
                [See full installation instructions and options](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md)

                File Name | Description
                -- | --
                [Winget package](https://winget.run/pkg/rnwood/smtp4dev/desktop)| Rnwood.Smtp4dev.Desktop Winget package (recommended easy option for Win10/11)
                [Winget package](https://winget.run/pkg/rnwood/smtp4dev)| Rnwood.Smtp4dev Winget package Win10/11)
                [Rnwood.Smtp4dev-win-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-win-x64-$(tag).zip) | Windows x64 binary standalone - Server edition
                [Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev.Desktop-win-x64-$(tag).zip) | Windows x64 binary standalone - Desktop app edition.
                [Rnwood.Smtp4dev-win-arm64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-win-arm64-$(tag).zip) | Windows ARM 62-bit binary standalone
                [Rnwood.Smtp4dev-linux-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-linux-x64-$(tag).zip) | Linux x64 (Intel 64 bit) binary standalone
                [Rnwood.Smtp4dev-linux-musl-x64-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-linux-musl-x64-$(tag).zip) | Linux MUSL x64 binary standalone for Linux distros using MUSL libc
                [Rnwood.Smtp4dev-noruntime-$(tag).zip](../../releases/download/$(tag)/Rnwood.Smtp4dev-noruntime-$(tag).zip) | Architecture independent version. Should run on any platform where the .NET 8.0 (or greater) runtime is installed
                [Docker images for Windows and Linux](https://hub.docker.com/layers/rnwood/smtp4dev/$(tag)) - [How to use Docker image](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-in-docker)
                [.NET tool Rnwood.Smtp4dev $(tag)](https://www.nuget.org/packages/Rnwood.Smtp4dev/$(tag)) | .NET tool (recommended option for Mac OS) - [How to use dotnet tool](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-as-a-dotnet-global-tool)

 

              ${{ if eq(variables['isreleasebuild'], true) }}:
                action: edit
                isPreRelease: false
                changeLogCompareToRelease: lastFullRelease
              ${{ if not(eq(variables['isreleasebuild'], true)) }}:
                action: create
                isPreRelease: true
                changeLogCompareToRelease: lastNonDraftRelease

              assets: $(Build.ArtifactStagingDirectory)/**/*.zip
          - task: NuGetCommand@2
            inputs:
              command: "push"
              packagesToPush: "$(Build.ArtifactStagingDirectory)/dotnetglobaltool/*.nupkg"
              nuGetFeedType: "external"
              publishFeedCredentials: "nuget_rnwood"
      - job: DockerReleaseTagLinux
        displayName: Docker Release Tag - Linux
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "ubuntu-22.04"
        steps:
          - checkout: none
          - task: Docker@2
            displayName: Login.
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Tag release
            inputs:
              targetType: inline
              script: | 
                if ([bool]::Parse("$(isreleasebuild)")) {
                    $version = [version] "$(version)"
                    $dockertags = "latest v$($version.Major) v$($version.Major).$($version.Minor)"
                } elseif ([bool]::Parse("$(iscibuild)")) {
                    $dockertags = "prerelease"
                } else {
                    $dockertags = ""
                }
                write-host "Docker tags: $dockertags"

                docker pull $(docker_repo):linux-amd64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-amd64-$_
                  docker push $(docker_repo):linux-amd64-$_
                }

                docker pull $(docker_repo):linux-arm64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):linux-arm64-$(tag) $(docker_repo):linux-arm64-$_
                  docker push $(docker_repo):linux-arm64-$_
                }

      - job: DockerRelease
        displayName: Docker Release
        dependsOn: DockerReleaseTagLinux
        variables:
          DOCKER_CLI_EXPERIMENTAL: enabled
        pool:
          vmImage: "windows-2022"
        steps:
          - checkout: none
          - task: Docker@2
            displayName: Login
            inputs:
              containerRegistry: $(docker_registry)
              repository: $(docker_repo)
              command: login
          - task: PowerShell@2
            displayName: Tag release
            inputs:
              targetType: inline
              script: |
                if ([bool]::Parse("$(isreleasebuild)")) {
                    $version = [version] "$(version)"
                    $dockertags = "latest v$($version.Major) v$($version.Major).$($version.Minor)"
                } else {
                    $dockertags = "prerelease"
                }
                write-host "Docker tags: $dockertags"
                docker pull $(docker_repo):windows-ltsc2019-amd64-$(tag)
                docker pull $(docker_repo):windows-ltsc2022-amd64-$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker tag $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):windows-ltsc2019-amd64-$_
                  docker push $(docker_repo):windows-ltsc2019-amd64-$_
                  docker tag $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):windows-ltsc2022-amd64-$_
                  docker push $(docker_repo):windows-ltsc2022-amd64-$_
                }

                docker manifest create $(docker_repo):$(tag) $(docker_repo):windows-ltsc2019-amd64-$(tag) $(docker_repo):windows-ltsc2022-amd64-$(tag) $(docker_repo):linux-amd64-$(tag) $(docker_repo):linux-arm64-$(tag)
                docker manifest push $(docker_repo):$(tag)

                ($dockertags.Split(" ", [StringSplitOptions]::RemoveEmptyEntries)) | foreach-object {
                  docker manifest create $(docker_repo):$_ $(docker_repo):windows-ltsc2019-amd64-$_ $(docker_repo):windows-ltsc2022-amd64-$_ $(docker_repo):linux-amd64-$_ $(docker_repo):linux-arm64-$_
                  docker manifest push $(docker_repo):$_
                }

  - stage: NotifyOnFailure
    displayName: Notify on Build Failure
    condition: and(failed(), eq(variables['Build.Reason'], 'PullRequest'))
    dependsOn: 
      - Build
    jobs:
      - job: NotifyCopilot
        displayName: Notify Copilot of Build Failure
        pool:
          vmImage: "ubuntu-22.04"
        variables:
          - name: System.Debug
            value: true
        steps:
          - checkout: none
          - task: PowerShell@2
            displayName: Comment on PR to notify Copilot
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: inline
              script: |
                $repoOwner = "rnwood"
                $repoName = "smtp4dev"
                $prNumber = "$(System.PullRequest.PullRequestNumber)"
                $buildUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                $buildId = "$(Build.BuildId)"
                $organizationUri = "$(System.TeamFoundationCollectionUri)"
                $projectName = "$(System.TeamProject)"
                
                # Check if PR is assigned to copilot before proceeding
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                try {
                  $prUri = "https://api.github.com/repos/$repoOwner/$repoName/pulls/$prNumber"
                  $prDetails = Invoke-RestMethod -Uri $prUri -Headers $headers -Method Get
                  
                  # Check if copilot is assigned to this PR
                  $copilotAssigned = $prDetails.assignees | Where-Object { $_.login -eq "copilot" }
                  
                  if (-not $copilotAssigned) {
                    Write-Host "PR #$prNumber is not assigned to @copilot. Skipping notification."
                    exit 0
                  }
                  
                  Write-Host "PR #$prNumber is assigned to @copilot. Proceeding with notification."
                } catch {
                  Write-Error "Failed to check PR assignees: $_"
                  Write-Host "Proceeding with notification as fallback."
                }
                
                # Note: We no longer extract detailed build logs here to reduce comment size
                # and encourage @copilot to access the live build data directly from Azure DevOps
                
                $commentBody = @"
                @copilot The build triggered by this PR has failed. **Please use the Azure DevOps REST API to investigate and fix the issues.**
                
                **üö® IMPORTANT: Only proceed if this is the most recent commit on your branch. If a newer commit exists, ignore this notification.**
                
                **Build Details:**
                - Build ID: $buildId
                - Build URL: $buildUrl (for reference)
                - Commit: $("$(System.PullRequest.SourceCommitId)".Substring(0, 7))
                - Build Status: FAILED
                
                **Instructions for @copilot:**
                1. **First verify this is the latest commit** - If $("$(System.PullRequest.SourceCommitId)".Substring(0, 7)) is not the most recent commit in this PR branch, ignore this notification
                2. **Use Azure DevOps REST API to get build details and failures:**
                   ```bash
                   # Get build overview
                   curl -s "https://dev.azure.com/rnwood/smtp4dev/_apis/build/builds/$buildId?api-version=6.0" | jq '{status: .status, result: .result, sourceVersion: .sourceVersion}'
                   
                   # Get failed tasks and their logs
                   curl -s "https://dev.azure.com/rnwood/smtp4dev/_apis/build/builds/$buildId/timeline?api-version=6.0" | jq '.records[] | select(.result == "failed") | {name: .name, task: .task.name, errorCount: .errorCount, logId: .log.id}'
                   
                   # Get specific error details from a failed task log (replace LOG_ID)
                   curl -s "https://dev.azure.com/rnwood/smtp4dev/_apis/build/builds/$buildId/logs/LOG_ID" | grep -i "error\|failed"
                   ```
                3. **Analyze the error messages** from the API responses to identify compilation errors, test failures, or other issues
                4. **Make targeted fixes** based on the specific error messages found
                5. **Build locally** after making fixes to verify the solution
                
                **The Azure DevOps REST API provides comprehensive build failure information without requiring browser access.**
                "@
                
                $headers = @{
                  'Authorization' = "token $env:GITHUB_TOKEN"
                  'Accept' = 'application/vnd.github.v3+json'
                  'User-Agent' = 'Azure-DevOps-Pipeline'
                }
                
                $body = @{
                  body = $commentBody
                } | ConvertTo-Json -Depth 10
                
                $uri = "https://api.github.com/repos/$repoOwner/$repoName/issues/$prNumber/comments"
                
                try {
                  $response = Invoke-RestMethod -Uri $uri -Method Post -Headers $headers -Body $body -ContentType 'application/json'
                  Write-Host "Successfully posted comment to PR #$prNumber"
                  Write-Host "Comment URL: $($response.html_url)"
                } catch {
                  Write-Error "Failed to post comment to PR #$prNumber : $_"
                  Write-Host "URI: $uri"
                  Write-Host "PR Number: $prNumber"
                  Write-Host "Error Body Length: $($commentBody.Length)"
                  exit 1
                }
